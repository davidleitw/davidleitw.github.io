<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - davidLei</title>
        <link>http://example.org/posts/</link>
        <description>All Posts | davidLei</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>davidleitw@gmail.com (davidlei)</managingEditor>
            <webMaster>davidleitw@gmail.com (davidlei)</webMaster><lastBuildDate>Sat, 08 Jan 2022 03:12:53 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Linux waitqueue 原始碼解讀</title>
    <link>http://example.org/posts/linux_wake_queue1/</link>
    <pubDate>Sat, 08 Jan 2022 03:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/linux_wake_queue1/</guid>
    <description><![CDATA[本文章環境基於 Linux v4.14.259
 概述 waitqueue 如同其名，是 kernel 中管理一些在等待資源的 task 的資料結構，在 task 還沒辦法獲得資源時，會先將其放入 waitqueue 等待特定條件或者資源準備就緒才會把該 task 喚醒。
waitqueue 有定義兩種資料結構
 wait_queue_head: waitqueue 的 head wait_queue_entry: 來表示每個在 waitqueue 的元素  waitqueue 所有的實現都是基於 kernel 內建的 double circular linked list 來實現，所以本身的設計非常簡潔。 以下為 waitqueue 基本的 data struct 定義，位在 /include/linux/wait.h
wait_queue_head_t struct wait_queue_head { spinlock_t	lock; // 自旋鎖 	struct list_head	head; // 指向 prev, next entry. }; typedef struct wait_queue_head wait_queue_head_t; 初始化 waitqueue 要建立新的 waitqueue，必須要先初始化 wait_queue_head_t 結構，透過 init_waitqueue_head，定義如下]]></description>
</item><item>
    <title>Linux schedule 原始碼解讀</title>
    <link>http://example.org/posts/linux_get_context_switch/</link>
    <pubDate>Fri, 07 Jan 2022 03:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/linux_get_context_switch/</guid>
    <description><![CDATA[本文章環境基於 Linux v4.14.259
 第一次 trace 整個排程的流程，kernel 真的是個大坑，有很多概念都還不熟，只能整理大概的流程，具體很多 function 的作用都沒辦法很好的說明，希望之後可以多閱讀 source code，把相關的知識慢慢補齊，拼湊成完整的知識。
schedule 要 trace 排程器要先找到 schedule 的入口，定義在 kernel/sched/core.c，函式定義如下
asmlinkage __visible void __sched schedule(void) { struct task_struct *tsk = current; // 避免 deadlock 	sched_submit_work(tsk); do { // 排程本身無法搶佔，等排程完畢再開啟 	preempt_disable(); __schedule(false); // 排程完成，開啟搶佔功能 	sched_preempt_enable_no_resched(); } while (need_resched()); // 檢查是不是被設置 TIF_NEED_RESCHED，如果被設置就重新排程 } EXPORT_SYMBOL(schedule); sched_submit_work static inline void sched_submit_work(struct task_struct *tsk) { if (!tsk-&gt;state || tsk_is_pi_blocked(tsk)) return; /* * If we are going to sleep and we have plugged IO queued, * make sure to submit it to avoid deadlocks.]]></description>
</item><item>
    <title>Linux fork() 底層實作流程整理</title>
    <link>http://example.org/posts/linux_fork_01/</link>
    <pubDate>Wed, 05 Jan 2022 00:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/linux_fork_01/</guid>
    <description><![CDATA[本文章環境基於 Linux v4.14.259
 因為作業需要在 task_struct 中加入 counter 並且觀察排程器的行為，所以在這邊寫一份筆記來紀錄一下在 linux 中一個 process 建立的時候在哪裡初始化，從 fork() 開始慢慢 trace 下去。
在 Linux 中並沒有明確區分 process 跟 thread, task_struct 可以根據創立條件的不同代表 process 或者 thread。
從實作的角度看可以有以下幾種 system call 建立新的 task_struct:
 建立 user process: fork, vfork, clone 建立 kernel thread: kernel_thread, kthread_create  以上這些 API 最後都會呼叫 /kernel/fork.c 中的 _do_fork 來進行 create task_struct 的操作，只是會根據給的參數不同，來決定建立出來的 task_struct 的性質，以上幾個 system call 的差別也可以參考 The difference between fork(), vfork(), exec() and clone()]]></description>
</item><item>
    <title>leetcode 997. Find the Town Judge [Easy]</title>
    <link>http://example.org/posts/lc997/</link>
    <pubDate>Tue, 04 Jan 2022 00:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc997/</guid>
    <description><![CDATA[題目敘述 在小鎮中有 N 個人，其中裡面有一個是 Judge，成為 Judge 要滿足兩個條件
 Judge 本身不相信任何人 其他 N-1 個人都相信 Judge  一開始看到這個題目是往圖的方向去思考，後來寫出來的結果不盡理想，最後換個思路直接用一個大小為 N 的 array 來紀錄，如果 A 信任 B 那就 array[B]++, array[A]--，如果 Judge 存在，它就會有 N-1 票，如果在其中支持的任一個人，在支持的過程就會 -1 票，喪失成為法官的條件。
解題紀錄 class Solution { public: int findJudge(int n, vector&lt;vector&lt;int&gt;&gt;&amp; trust) { vector&lt;int&gt; record(n+1, 0); for (int i = 0; i &lt; trust.size(); ++i) { record[trust[i][0]]--; record[trust[i][1]]++; } for (int i = 1; i &lt;= n; ++i) { if (record[i] == n-1) { return i; } } return -1; } }; ]]></description>
</item><item>
    <title>leetcode 1010. Pairs of Songs With Total Durations Divisible by 60 [Medium]</title>
    <link>http://example.org/posts/lc1010/</link>
    <pubDate>Sun, 02 Jan 2022 01:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc1010/</guid>
    <description><![CDATA[題目敘述 在一個陣列中找出兩兩相加是 60 的倍數的組合數。
解題紀錄 這個題目如果純粹的硬是把所有的組合都加過一次，一定會 time out，所以基本上要從 O(n) 的作法去嘗試。
假設 x = 57，那相加 3, 63 ... 都可以湊到 60 的倍數，所以我們只要用一個大小 60 的 array 來存 time[i] % 60 的結果就好了，今天 x = 57 的情況我們只要去 array 中查找 array[60 - 57 % 60] = array[3] 就可以獲得在此之前所有曾經出現過可以跟 57 湊成 60 倍數的資料了。
class Solution { public: int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) { int cnt = 0; int m[60] = {0}; for (int i = 0; i &lt; time.size(); ++i) { cnt += m[time[i]%60 == 0 ?]]></description>
</item><item>
    <title>leetcode 1026. Maximum Difference Between Node and Ancestor [Medium]</title>
    <link>http://example.org/posts/lc1026/</link>
    <pubDate>Sat, 01 Jan 2022 01:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc1026/</guid>
    <description><![CDATA[題目敘述 給一棵二元樹，回傳某個節點與其祖先節點的最大的差(絕對值)。
解題紀錄 DFS 用 DFS 尋訪每個節點，並且順便紀錄到這個節點之前的 max, min value，這樣子最大的差就是 max - min。
class Solution { public: int maxAncestorDiff(TreeNode* root) { return get_max_different(root, root-&gt;val, root-&gt;val); } int get_max_different(TreeNode *root, int maxv, int minv) { if (!root) return maxv - minv; maxv = max(maxv, root-&gt;val); minv = min(minv, root-&gt;val); return max(get_max_different(root-&gt;left, maxv, minv), get_max_different(root-&gt;right, maxv, minv)); } }; #pragma GCC optimize(&#34;Ofast&#34;) #pragma GCC target(&#34;avx,avx2,fma&#34;) static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}(); ]]></description>
</item><item>
    <title>leetcode 116. Populating Next Right Pointers in Each Node [Medium]</title>
    <link>http://example.org/posts/lc116/</link>
    <pubDate>Wed, 29 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc116/</guid>
    <description><![CDATA[題目敘述 給定一個 perfect binary tree，定義 next 指標，root-&gt;next 為空，每個節點的 left child 的 next 為 right child。每個節點 right child 的 next 為該節點 next 的 left child。
用中文有點難表達，直接看圖吧。
解題流程 這題跟很多 tree 的題目一樣，可以用 BFS 或者 DFS 兩種方式去實現。
BFS 用 BFS 的解法，就是在每個 level 找到最左邊的 Node 當作開頭，往右開始每個節點都用 next 指標連結。
class Solution { public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node*&gt; q; q.push(root); while (!q.empty()) { Node *curr; const int qsize = q.size(); for (int i = 0; i &lt; qsize; ++i) { Node *n = q.]]></description>
</item><item>
    <title>利用 vagrant 執行自己編譯的 kernel，快速搭建實驗環境</title>
    <link>http://example.org/posts/vagrant_001/</link>
    <pubDate>Tue, 28 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/vagrant_001/</guid>
    <description><![CDATA[vagrant vagrant 是一款建立及管理虛擬機的工具，利用 vagrant 可以快速在本機端架設實驗環境，並且可以把自己習慣的環境包裝後在任何有安裝 vagrant 的電腦執行，達到 IaC(Infrastructure as Code) 的特性，使用 vagrant 可以大幅降低環境的架設時間，趁這個機會順便學習一下基本的用法。
這學期在修 linux 的課程會有添加 system call 或者改 kernel 的需求，所以這篇文章紀錄一下如何使用 vagrant 來執行自己編譯好的 kernel，以及一些 vagrant 的基本用法，用虛擬機做實驗也降低了把自己的環境搞壞的風險。
install 安裝可以參考 官方網站，在 ubuntu 的環境安裝 vagrant 可以用以下指令:
$ curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - $ sudo apt-add-repository &#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main&#34; $ sudo apt-get update &amp;&amp; sudo apt-get install vagrant $ vagrant plugin install vagrant-vbguest vagrant 只是一個管理虛擬機的工具，底層可以選擇 VirtualBox, VMware, AWS.. 等不同的虛擬機環境，在 linux 的主機中最方便安裝的就是 VirtualBox，所以在正式使用之前要記得先安裝 VirtualBox。]]></description>
</item><item>
    <title>leetcode 876. Middle of the Linked List [Medium]</title>
    <link>http://example.org/posts/lc876/</link>
    <pubDate>Tue, 28 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc876/</guid>
    <description><![CDATA[題目敘述 獲得 linked list 的 middle 節點。
經典的快慢指標問題，但是這題找到中間節點之後不需要前面的資料，所以直接用 head 來當 slow 指標。
解題流程 class Solution { public: ListNode* middleNode(ListNode* head) { ListNode *fast = head; while (fast &amp;&amp; fast-&gt;next) { fast = fast-&gt;next-&gt;next; head = head-&gt;next; } return head; } }; ]]></description>
</item><item>
    <title>leetcode 476. Number Complement [Medium]</title>
    <link>http://example.org/posts/lc476/</link>
    <pubDate>Mon, 27 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc476/</guid>
    <description><![CDATA[題目敘述 對一個整數的有效位元做位元轉換(ones' complement)，像是 5 = 101，經過轉換之後結果 2 = 010，前面沒有用到的 bit 則是不做任何操作。
思路 這題算是 Bit Manipulation 的入門題目，很適合練習 bit 的思考方式。剛好這類型的題目之前沒什麼做過，所以這邊來紀錄一下。
因為這題的範圍限制 1 &lt;= num &lt; 2^31，所以可確保第一個 bit 為0
找第一個有效位元 我的想法是先從左邊第一個 bit 開始找，找到第一個 1 ，後面所有的 bit 就都是有效位數，再一一反轉。
要判斷左邊第一個位元是不是 1 可以寫成
if ((num &amp; (1 &lt;&lt; 31)) == 1) { // do something } 可以利用這個方式先找到第一個 1 的所在，在對於後面的 bit 做反轉。
反轉 bits  (一): 逐個 bit 反轉, 利用 XOR  class Solution { public: int findComplement(int num) { bool flag = false; for (int shift = 31; shift &gt;= 0; shift--) { if ((num &amp; (1 &lt;&lt; shift)) !]]></description>
</item></channel>
</rss>
