<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - davidLei</title>
        <link>http://example.org/posts/</link>
        <description>All Posts | davidLei</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>davidleitw@gmail.com (davidlei)</managingEditor>
            <webMaster>davidleitw@gmail.com (davidlei)</webMaster><lastBuildDate>Sun, 02 Jan 2022 01:12:53 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>leetcode 1010. Pairs of Songs With Total Durations Divisible by 60 [Medium]</title>
    <link>http://example.org/posts/lc1010/</link>
    <pubDate>Sun, 02 Jan 2022 01:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc1010/</guid>
    <description><![CDATA[題目敘述 在一個陣列中找出兩兩相加是 60 的倍數的組合數。
解題紀錄 這個題目如果純粹的硬是把所有的組合都加過一次，一定會 time out，所以基本上要從 O(n) 的作法去嘗試。
假設 x = 57，那相加 3, 63 ... 都可以湊到 60 的倍數，所以我們只要用一個大小 60 的 array 來存 time[i] % 60 的結果就好了，今天 x = 57 的情況我們只要去 array 中查找 array[60 - 57 % 60] = array[3] 就可以獲得在此之前所有曾經出現過可以跟 57 湊成 60 倍數的資料了。
class Solution { public: int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) { int cnt = 0; int m[60] = {0}; for (int i = 0; i &lt; time.size(); ++i) { cnt += m[time[i]%60 == 0 ?]]></description>
</item><item>
    <title>leetcode 1026. Maximum Difference Between Node and Ancestor [Medium]</title>
    <link>http://example.org/posts/lc1026/</link>
    <pubDate>Sat, 01 Jan 2022 01:12:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc1026/</guid>
    <description><![CDATA[題目敘述 給一棵二元樹，回傳某個節點與其祖先節點的最大的差(絕對值)。
解題紀錄 DFS 用 DFS 尋訪每個節點，並且順便紀錄到這個節點之前的 max, min value，這樣子最大的差就是 max - min。
class Solution { public: int maxAncestorDiff(TreeNode* root) { return get_max_different(root, root-&gt;val, root-&gt;val); } int get_max_different(TreeNode *root, int maxv, int minv) { if (!root) return maxv - minv; maxv = max(maxv, root-&gt;val); minv = min(minv, root-&gt;val); return max(get_max_different(root-&gt;left, maxv, minv), get_max_different(root-&gt;right, maxv, minv)); } }; #pragma GCC optimize(&#34;Ofast&#34;) #pragma GCC target(&#34;avx,avx2,fma&#34;) static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}(); ]]></description>
</item><item>
    <title>leetcode 116. Populating Next Right Pointers in Each Node [Medium]</title>
    <link>http://example.org/posts/lc116/</link>
    <pubDate>Wed, 29 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc116/</guid>
    <description><![CDATA[題目敘述 給定一個 perfect binary tree，定義 next 指標，root-&gt;next 為空，每個節點的 left child 的 next 為 right child。每個節點 right child 的 next 為該節點 next 的 left child。
用中文有點難表達，直接看圖吧。
解題流程 這題跟很多 tree 的題目一樣，可以用 BFS 或者 DFS 兩種方式去實現。
BFS 用 BFS 的解法，就是在每個 level 找到最左邊的 Node 當作開頭，往右開始每個節點都用 next 指標連結。
class Solution { public: Node* connect(Node* root) { if (!root) return root; queue&lt;Node*&gt; q; q.push(root); while (!q.empty()) { Node *curr; const int qsize = q.size(); for (int i = 0; i &lt; qsize; ++i) { Node *n = q.]]></description>
</item><item>
    <title>利用 vagrant 執行自己編譯的 kernel，快速搭建實驗環境</title>
    <link>http://example.org/posts/vagrant_001/</link>
    <pubDate>Tue, 28 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/vagrant_001/</guid>
    <description><![CDATA[vagrant vagrant 是一款建立及管理虛擬機的工具，利用 vagrant 可以快速在本機端架設實驗環境，並且可以把自己習慣的環境包裝後在任何有安裝 vagrant 的電腦執行，達到 IaC(Infrastructure as Code) 的特性，使用 vagrant 可以大幅降低環境的架設時間，趁這個機會順便學習一下基本的用法。
這學期在修 linux 的課程會有添加 system call 或者改 kernel 的需求，所以這篇文章紀錄一下如何使用 vagrant 來執行自己編譯好的 kernel，以及一些 vagrant 的基本用法，用虛擬機做實驗也降低了把自己的環境搞壞的風險。
install 安裝可以參考 官方網站，在 ubuntu 的環境安裝 vagrant 可以用以下指令:
$ curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - $ sudo apt-add-repository &#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main&#34; $ sudo apt-get update &amp;&amp; sudo apt-get install vagrant $ vagrant plugin install vagrant-vbguest vagrant 只是一個管理虛擬機的工具，底層可以選擇 VirtualBox, VMware, AWS.. 等不同的虛擬機環境，在 linux 的主機中最方便安裝的就是 VirtualBox，所以在正式使用之前要記得先安裝 VirtualBox。]]></description>
</item><item>
    <title>leetcode 876. Middle of the Linked List [Medium]</title>
    <link>http://example.org/posts/lc876/</link>
    <pubDate>Tue, 28 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc876/</guid>
    <description><![CDATA[題目敘述 獲得 linked list 的 middle 節點。
經典的快慢指標問題，但是這題找到中間節點之後不需要前面的資料，所以直接用 head 來當 slow 指標。
解題流程 class Solution { public: ListNode* middleNode(ListNode* head) { ListNode *fast = head; while (fast &amp;&amp; fast-&gt;next) { fast = fast-&gt;next-&gt;next; head = head-&gt;next; } return head; } }; ]]></description>
</item><item>
    <title>leetcode 476. Number Complement [Medium]</title>
    <link>http://example.org/posts/lc476/</link>
    <pubDate>Mon, 27 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc476/</guid>
    <description><![CDATA[題目敘述 對一個整數的有效位元做位元轉換(ones' complement)，像是 5 = 101，經過轉換之後結果 2 = 010，前面沒有用到的 bit 則是不做任何操作。
思路 這題算是 Bit Manipulation 的入門題目，很適合練習 bit 的思考方式。剛好這類型的題目之前沒什麼做過，所以這邊來紀錄一下。
因為這題的範圍限制 1 &lt;= num &lt; 2^31，所以可確保第一個 bit 為0
找第一個有效位元 我的想法是先從左邊第一個 bit 開始找，找到第一個 1 ，後面所有的 bit 就都是有效位數，再一一反轉。
要判斷左邊第一個位元是不是 1 可以寫成
if ((num &amp; (1 &lt;&lt; 31)) == 1) { // do something } 可以利用這個方式先找到第一個 1 的所在，在對於後面的 bit 做反轉。
反轉 bits  (一): 逐個 bit 反轉, 利用 XOR  class Solution { public: int findComplement(int num) { bool flag = false; for (int shift = 31; shift &gt;= 0; shift--) { if ((num &amp; (1 &lt;&lt; shift)) !]]></description>
</item><item>
    <title>leetcode 198. House Robber [Medium]</title>
    <link>http://example.org/posts/lc198/</link>
    <pubDate>Sun, 26 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc198/</guid>
    <description><![CDATA[題目敘述 看題目直覺想到是 dp 的題型，在一維陣列中取 n 個不相鄰的數字，使其有最大的總和。
這題算是基本的 dp 題型，本身不難想，底下的解答還能優化成使用 2 個變數去紀錄狀態。
解題紀錄 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return nums[0]; int dp[100] = {0}; dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); ++i) { dp[i] = max(dp[i-1], dp[i-2]+nums[i]); } return dp[nums.size()-1]; } }; ]]></description>
</item><item>
    <title>leetcode 973. K Closest Points to Origin [Medium]</title>
    <link>http://example.org/posts/lc973/</link>
    <pubDate>Sun, 26 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc973/</guid>
    <description><![CDATA[題目敘述 給 n 個座標，返回距離原點最近的 k 個座標
解題紀錄 解法一 因為要返回的只有座標點，所以其實不需要開根號，直接用 (x^2 + y^2) 比較即可。
class Solution { public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) { sort(points.begin(), points.end(), [this](vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) { return get_distance(a) &lt; get_distance(b); }); return vector&lt;vector&lt;int&gt;&gt;(points.begin(), points.begin() + k); } inline int get_distance(vector&lt;int&gt; &amp;point) { return point[0] * point[0] + point[1] * point[1]; } }; #pragma GCC optimize(&#34;Ofast&#34;) #pragma GCC target(&#34;avx,avx2,fma&#34;) static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}(); 解法二 求最近的 k 個節點，其實可以換個思路，利用 maxHeap 來實現。]]></description>
</item><item>
    <title>leetcode 227. Basic Calculator II [Medium]</title>
    <link>http://example.org/posts/lc227/</link>
    <pubDate>Sat, 25 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc227/</guid>
    <description><![CDATA[題目敘述 輸入算式的字串，返回解答。運算子只有 +, -, *, /，這題還沒有出現包含括號的情況。
解題紀錄 這次是直覺的用 stack 解出來，但是仔細思考過後發覺好像不一定要用 stack，可以用變數去存資料，之後待補XD
class Solution { public: int calculate(string s) { long long int tmp; long long int num = 0; int len = s.size(); stack&lt;long long int&gt; result; char op_code = &#39;+&#39;; for (int i = 0; i &lt; len; ++i) { if (isnumber(s[i])) { num = num * 10 + s[i] - &#39;0&#39;; } if (!isnumber(s[i]) &amp;&amp; s[i] != &#39; &#39; || i == len-1) { switch (op_code) { case &#39;+&#39;: result.]]></description>
</item><item>
    <title>golang 定時器(一) Time, Ticker 基本用法整理</title>
    <link>http://example.org/posts/time01/</link>
    <pubDate>Fri, 24 Dec 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/time01/</guid>
    <description><![CDATA[在後端中常常會有需要定時的場景出現，像是如果處理 request 超過一定時間就觸發 timeout，或者利用定時的功能推送請求等等，這篇文章將會簡單介紹一些 golang 內建的定時器功能，以及可能會遇到的坑。
所有有關定時器的功能都在 time 內，使用前必須先
import &#34;time&#34; 單次定時事件 - Timer // src/time/sleep.go  // The Timer type represents a single event. // When the Timer expires, the current time will be sent on C, // unless the Timer was created by AfterFunc. // A Timer must be created with NewTimer or AfterFunc. type Timer struct { C &lt;- chan Time r runtimeTimer } 在 golang 中 Timer 可以用來表示一個單一事件，可以用 NewTimer 或者 AfterFunc 兩個 function 去建立一個新的 Timer，簡單的使用範例如下]]></description>
</item></channel>
</rss>
