<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>davidLei</title>
    <link>http://example.org/</link>
    <description>Recent content on davidLei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>davidleitw@gmail.com (davidlei)</managingEditor>
    <webMaster>davidleitw@gmail.com (davidlei)</webMaster>
    <lastBuildDate>Sun, 02 Jan 2022 01:12:53 +0800</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>leetcode 1010. Pairs of Songs With Total Durations Divisible by 60 [Medium]</title>
      <link>http://example.org/posts/lc1010/</link>
      <pubDate>Sun, 02 Jan 2022 01:12:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc1010/</guid>
      <description>題目敘述 在一個陣列中找出兩兩相加是 60 的倍數的組合數。
解題紀錄 這個題目如果純粹的硬是把所有的組合都加過一次，一定會 time out，所以基本上要從 O(n) 的作法去嘗試。
假設 x = 57，那相加 3, 63 ... 都可以湊到 60 的倍數，所以我們只要用一個大小 60 的 array 來存 time[i] % 60 的結果就好了，今天 x = 57 的情況我們只要去 array 中查找 array[60 - 57 % 60] = array[3] 就可以獲得在此之前所有曾經出現過可以跟 57 湊成 60 倍數的資料了。
class Solution { public: int numPairsDivisibleBy60(vector&amp;lt;int&amp;gt;&amp;amp; time) { int cnt = 0; int m[60] = {0}; for (int i = 0; i &amp;lt; time.size(); ++i) { cnt += m[time[i]%60 == 0 ?</description>
    </item>
    
    <item>
      <title>leetcode 1026. Maximum Difference Between Node and Ancestor [Medium]</title>
      <link>http://example.org/posts/lc1026/</link>
      <pubDate>Sat, 01 Jan 2022 01:12:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc1026/</guid>
      <description>題目敘述 給一棵二元樹，回傳某個節點與其祖先節點的最大的差(絕對值)。
解題紀錄 DFS 用 DFS 尋訪每個節點，並且順便紀錄到這個節點之前的 max, min value，這樣子最大的差就是 max - min。
class Solution { public: int maxAncestorDiff(TreeNode* root) { return get_max_different(root, root-&amp;gt;val, root-&amp;gt;val); } int get_max_different(TreeNode *root, int maxv, int minv) { if (!root) return maxv - minv; maxv = max(maxv, root-&amp;gt;val); minv = min(minv, root-&amp;gt;val); return max(get_max_different(root-&amp;gt;left, maxv, minv), get_max_different(root-&amp;gt;right, maxv, minv)); } }; #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma GCC target(&amp;#34;avx,avx2,fma&amp;#34;) static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}(); </description>
    </item>
    
    <item>
      <title>leetcode 116. Populating Next Right Pointers in Each Node [Medium]</title>
      <link>http://example.org/posts/lc116/</link>
      <pubDate>Wed, 29 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc116/</guid>
      <description>題目敘述 給定一個 perfect binary tree，定義 next 指標，root-&amp;gt;next 為空，每個節點的 left child 的 next 為 right child。每個節點 right child 的 next 為該節點 next 的 left child。
用中文有點難表達，直接看圖吧。
解題流程 這題跟很多 tree 的題目一樣，可以用 BFS 或者 DFS 兩種方式去實現。
BFS 用 BFS 的解法，就是在每個 level 找到最左邊的 Node 當作開頭，往右開始每個節點都用 next 指標連結。
class Solution { public: Node* connect(Node* root) { if (!root) return root; queue&amp;lt;Node*&amp;gt; q; q.push(root); while (!q.empty()) { Node *curr; const int qsize = q.size(); for (int i = 0; i &amp;lt; qsize; ++i) { Node *n = q.</description>
    </item>
    
    <item>
      <title>利用 vagrant 執行自己編譯的 kernel，快速搭建實驗環境</title>
      <link>http://example.org/posts/vagrant_001/</link>
      <pubDate>Tue, 28 Dec 2021 01:05:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/vagrant_001/</guid>
      <description>vagrant vagrant 是一款建立及管理虛擬機的工具，利用 vagrant 可以快速在本機端架設實驗環境，並且可以把自己習慣的環境包裝後在任何有安裝 vagrant 的電腦執行，達到 IaC(Infrastructure as Code) 的特性，使用 vagrant 可以大幅降低環境的架設時間，趁這個機會順便學習一下基本的用法。
這學期在修 linux 的課程會有添加 system call 或者改 kernel 的需求，所以這篇文章紀錄一下如何使用 vagrant 來執行自己編譯好的 kernel，以及一些 vagrant 的基本用法，用虛擬機做實驗也降低了把自己的環境搞壞的風險。
install 安裝可以參考 官方網站，在 ubuntu 的環境安裝 vagrant 可以用以下指令:
$ curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - $ sudo apt-add-repository &amp;#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main&amp;#34; $ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install vagrant $ vagrant plugin install vagrant-vbguest vagrant 只是一個管理虛擬機的工具，底層可以選擇 VirtualBox, VMware, AWS.. 等不同的虛擬機環境，在 linux 的主機中最方便安裝的就是 VirtualBox，所以在正式使用之前要記得先安裝 VirtualBox。</description>
    </item>
    
    <item>
      <title>leetcode 876. Middle of the Linked List [Medium]</title>
      <link>http://example.org/posts/lc876/</link>
      <pubDate>Tue, 28 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc876/</guid>
      <description>題目敘述 獲得 linked list 的 middle 節點。
經典的快慢指標問題，但是這題找到中間節點之後不需要前面的資料，所以直接用 head 來當 slow 指標。
解題流程 class Solution { public: ListNode* middleNode(ListNode* head) { ListNode *fast = head; while (fast &amp;amp;&amp;amp; fast-&amp;gt;next) { fast = fast-&amp;gt;next-&amp;gt;next; head = head-&amp;gt;next; } return head; } }; </description>
    </item>
    
    <item>
      <title>leetcode 476. Number Complement [Medium]</title>
      <link>http://example.org/posts/lc476/</link>
      <pubDate>Mon, 27 Dec 2021 01:05:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc476/</guid>
      <description>題目敘述 對一個整數的有效位元做位元轉換(ones&#39; complement)，像是 5 = 101，經過轉換之後結果 2 = 010，前面沒有用到的 bit 則是不做任何操作。
思路 這題算是 Bit Manipulation 的入門題目，很適合練習 bit 的思考方式。剛好這類型的題目之前沒什麼做過，所以這邊來紀錄一下。
因為這題的範圍限制 1 &amp;lt;= num &amp;lt; 2^31，所以可確保第一個 bit 為0
找第一個有效位元 我的想法是先從左邊第一個 bit 開始找，找到第一個 1 ，後面所有的 bit 就都是有效位數，再一一反轉。
要判斷左邊第一個位元是不是 1 可以寫成
if ((num &amp;amp; (1 &amp;lt;&amp;lt; 31)) == 1) { // do something } 可以利用這個方式先找到第一個 1 的所在，在對於後面的 bit 做反轉。
反轉 bits  (一): 逐個 bit 反轉, 利用 XOR  class Solution { public: int findComplement(int num) { bool flag = false; for (int shift = 31; shift &amp;gt;= 0; shift--) { if ((num &amp;amp; (1 &amp;lt;&amp;lt; shift)) !</description>
    </item>
    
    <item>
      <title>leetcode 198. House Robber [Medium]</title>
      <link>http://example.org/posts/lc198/</link>
      <pubDate>Sun, 26 Dec 2021 01:05:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc198/</guid>
      <description>題目敘述 看題目直覺想到是 dp 的題型，在一維陣列中取 n 個不相鄰的數字，使其有最大的總和。
這題算是基本的 dp 題型，本身不難想，底下的解答還能優化成使用 2 個變數去紀錄狀態。
解題紀錄 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 1) return nums[0]; int dp[100] = {0}; dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.size(); ++i) { dp[i] = max(dp[i-1], dp[i-2]+nums[i]); } return dp[nums.size()-1]; } }; </description>
    </item>
    
    <item>
      <title>leetcode 973. K Closest Points to Origin [Medium]</title>
      <link>http://example.org/posts/lc973/</link>
      <pubDate>Sun, 26 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc973/</guid>
      <description>題目敘述 給 n 個座標，返回距離原點最近的 k 個座標
解題紀錄 解法一 因為要返回的只有座標點，所以其實不需要開根號，直接用 (x^2 + y^2) 比較即可。
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; kClosest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; points, int k) { sort(points.begin(), points.end(), [this](vector&amp;lt;int&amp;gt; &amp;amp;a, vector&amp;lt;int&amp;gt; &amp;amp;b) { return get_distance(a) &amp;lt; get_distance(b); }); return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(points.begin(), points.begin() + k); } inline int get_distance(vector&amp;lt;int&amp;gt; &amp;amp;point) { return point[0] * point[0] + point[1] * point[1]; } }; #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma GCC target(&amp;#34;avx,avx2,fma&amp;#34;) static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}(); 解法二 求最近的 k 個節點，其實可以換個思路，利用 maxHeap 來實現。</description>
    </item>
    
    <item>
      <title>leetcode 227. Basic Calculator II [Medium]</title>
      <link>http://example.org/posts/lc227/</link>
      <pubDate>Sat, 25 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc227/</guid>
      <description>題目敘述 輸入算式的字串，返回解答。運算子只有 +, -, *, /，這題還沒有出現包含括號的情況。
解題紀錄 這次是直覺的用 stack 解出來，但是仔細思考過後發覺好像不一定要用 stack，可以用變數去存資料，之後待補XD
class Solution { public: int calculate(string s) { long long int tmp; long long int num = 0; int len = s.size(); stack&amp;lt;long long int&amp;gt; result; char op_code = &amp;#39;+&amp;#39;; for (int i = 0; i &amp;lt; len; ++i) { if (isnumber(s[i])) { num = num * 10 + s[i] - &amp;#39;0&amp;#39;; } if (!isnumber(s[i]) &amp;amp;&amp;amp; s[i] != &amp;#39; &amp;#39; || i == len-1) { switch (op_code) { case &amp;#39;+&amp;#39;: result.</description>
    </item>
    
    <item>
      <title>golang 定時器(一) Time, Ticker 基本用法整理</title>
      <link>http://example.org/posts/time01/</link>
      <pubDate>Fri, 24 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/time01/</guid>
      <description>在後端中常常會有需要定時的場景出現，像是如果處理 request 超過一定時間就觸發 timeout，或者利用定時的功能推送請求等等，這篇文章將會簡單介紹一些 golang 內建的定時器功能，以及可能會遇到的坑。
所有有關定時器的功能都在 time 內，使用前必須先
import &amp;#34;time&amp;#34; 單次定時事件 - Timer // src/time/sleep.go  // The Timer type represents a single event. // When the Timer expires, the current time will be sent on C, // unless the Timer was created by AfterFunc. // A Timer must be created with NewTimer or AfterFunc. type Timer struct { C &amp;lt;- chan Time r runtimeTimer } 在 golang 中 Timer 可以用來表示一個單一事件，可以用 NewTimer 或者 AfterFunc 兩個 function 去建立一個新的 Timer，簡單的使用範例如下</description>
    </item>
    
    <item>
      <title>leetcode 56. Merge Intervals [Medium]</title>
      <link>http://example.org/posts/lc56/</link>
      <pubDate>Fri, 24 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc56/</guid>
      <description>題目敘述 這題的題目本身意思很直觀，給很多 區間，然後將所有範圍重疊的 區間 合併。
思考 一開始在看到題目的時候沒有想清楚就開始寫了，起初的想法是把 case 分成三種，如下圖所示
這樣判斷起來很沒有效率，後來才想到可以利用排序的方式，來讓所有的 case B 都消失，簡化主要邏輯判斷。如果在寫題目的過程中，發現自己的寫法可能遇到物件出現在前後的 case，必須要先思考看看是否能透過排序來解決，在這題中，透過排序可以讓每個分段都按照 start 先排過一輪，就不會出線上圖 case B 的情況了。
解題流程 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { int length = intervals.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; solution; sort(intervals.begin(), intervals.end()); int cur = 0; while (cur &amp;lt; length) { int start = intervals[cur][0]; int end = intervals[cur][1]; int walker = cur + 1; while (walker &amp;lt; length) { if (intervals[walker][0] &amp;gt; end) { break; } end = max(end, intervals[walker][1]); walker++; } solution.</description>
    </item>
    
    <item>
      <title>leetcode 210. Course Schedule II [Medium]</title>
      <link>http://example.org/posts/lc210/</link>
      <pubDate>Thu, 23 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc210/</guid>
      <description>題目敘述 給一個 prerequisites，每個元素 prerequisites[i] = [a, b]，都代表如果想選 a 課程，必須先修過 b 課程。題目要求回傳可能的修課順序，如果不可能修過全部的課程，回傳一個空的陣列。
思考 什麼情況下會導致無法修過全部的課程? 考慮以下組合為例
 prerequisites[0] = (1, 0), 修課程 1 之前必須修過課程 0 prerequisites[1] = (2, 1), 修課程 2 之前必須修過課程 1 prerequisites[2] = (0, 2), 修課程 0 之前必須修過課程 2  如果轉成有向圖則會變成以下情況
所以說這題其實是一題圖論的題目，把修課的條件建立成一個 graph，然後用 dfs 去尋訪，如果偵測到 cycle 代表一定有課程沒辦法修到，回傳空陣列。
在 dfs 的過程中用 status 來紀錄每個節點的狀態，如果 status[cur] == 1，代表這個節點是目前尋訪的點，用 status 來判斷是否有 cycle 的存在。
解題紀錄 class Solution { public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(numCourses); // 建立有向圖  for (const auto &amp;amp;requisite: prerequisites) { graph[requisite[1]].</description>
    </item>
    
    <item>
      <title>leetcode 1306. Jump Game III [Medium]</title>
      <link>http://example.org/posts/lc1306/</link>
      <pubDate>Thu, 09 Dec 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc1306/</guid>
      <description>題目敘述 給定一非負整數陣列 arr，你一開始位於位置 start。當你位於索引值 i 時，你可以跳到 i + arr[i] 或是 i - arr[i]，判斷你是否可以抵達任何位置其陣列值為 0 。
注意你在任意時刻都不能跳出陣列。
限制： 1 ≦ arr.length ≦ 5 × 10 ^ 4 0 ≦ arr[i] &amp;lt; arr.length 0 ≦ start &amp;lt; arr.length
解題紀錄 簡單的 dfs 解決，用一個 vector&amp;lt;bool&amp;gt; 去紀錄該 index 是否走過，避免發生無限迴圈的情況，如果 record[index] == true 代表已經走過，直接返回 false，記得還要判斷這次 jump 之後有沒有跳出迴圈的範圍。
static const auto fastIO = []() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; }(); class Solution { public: int len; vector&amp;lt;bool&amp;gt; record; bool canReach(vector&amp;lt;int&amp;gt; &amp;amp;arr, int start) { len = arr.</description>
    </item>
    
    <item>
      <title>linux socket programming(三): socket programming 中常用的位置轉換函數</title>
      <link>http://example.org/posts/socket3/</link>
      <pubDate>Fri, 12 Nov 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/socket3/</guid>
      <description>一般我們在表示 ip 位置時都會寫成人類比較容易讀的形式，像是125.102.25.62
以 ipv4 來說，address 是由4個 byte，32個 bit所組成，在實務上我們常常需要做字串與實際數值(uint32_t)的轉換，linux 函式庫提供了一系列輔助位置轉換的 function。
一般來說，address 的實際數值都會用 in_addr 或者 in_addr_t 來表示 其本質就是 uint32_t，用總共 32 個 bits 來表示一個 IPv4 的地址
typedef uint32_t in_addr_t; // 4 byte struct in_addr { in_addr_t s_addr; }; 常用的有以下這五種
 只能用在 IPv4 的處理  inet_addr inet_aton inet_ntoa   兼容 Ipv4 與 IPv6  inet_pton inet_ntop    使用前必須先
#include &amp;lt;arpa/inet.h&amp;gt;inet_addr in_addr_t inet_addr(const char *cp) 功能: 將字串轉換成數值表示的 ip address
回傳: 假如輸入的地址合法，會回傳 uint32_t 的數值，若不合法則回傳 INADDR_NONE</description>
    </item>
    
    <item>
      <title>leetcode 222. Count Complete Tree Nodes [Medium]</title>
      <link>http://example.org/posts/lc222/</link>
      <pubDate>Wed, 27 Oct 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lc222/</guid>
      <description>題目連結
題目敘述 給予一棵 Complete Binary Tree，求節點個數。
Complete Binary Tree 定義 BFS 用最直觀的 BFS 來解，每從 queue 拿出一個節點，count 加一。
class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; int cnt = 0; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while (!q.empty()) { TreeNode *node = q.front(); q.pop(); if (node-&amp;gt;left) q.push(node-&amp;gt;left); if (node-&amp;gt;right) q.push(node-&amp;gt;right); cnt++; } return cnt; } }; Runtime: 24 ms, faster than 95.34% of C++ online submissions for Count Complete Tree Nodes.</description>
    </item>
    
    <item>
      <title>linux socket programming(二): socket 中用來存放地址的 sockaddr</title>
      <link>http://example.org/posts/socker2/</link>
      <pubDate>Tue, 26 Oct 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/socker2/</guid>
      <description>sockaddr sockaddr 是 socket 的通用地址結構，就如同一開始提到的，socket 除了在網路領域之外，也可以在很多不同的地方用來通訊。
sockaddr 結構，定義如下
typedef unsigned short int sa_family_t; #define	__SOCKADDR_COMMON(sa_prefix) \ sa_family_t sa_prefix##family  struct sockaddr { __SOCKADDR_COMMON (sa_);	/* Common data: address family and length. */ char sa_data[14];	/* Address data. */ }; // 上面的結構把巨集展開後，等價於下方的資料結構 struct sockaddr { unsigned short int sa_family; // 2 bytes  char sa_data[14]; // 14 bytes }; 後來的更新中，為了讓龐大的程式碼可讀性上升，新增了 sockaddr_in 的結構用來存取網路相關的應用， in 指的是 internet，sockaddr_in 專門用來存 IPv4 的相關地址。
IPv6 則是使用 sockaddr_in6 結構，在本文章主要會著重在 IPv4 相關的範例。</description>
    </item>
    
    <item>
      <title>linux socket programming(一): 什麼是 socket &amp; 創建一個新的 socket</title>
      <link>http://example.org/posts/socket1/</link>
      <pubDate>Mon, 25 Oct 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/socket1/</guid>
      <description>socket programming socket 本質上是一種 IPC (Inter-Process Communication) 的技術，用於兩個或多個 process 進行資料交換或者通訊。
在網路領域，socket 著重的不是同一台主機間 process 的通訊，而是不同主機執行的 process 互相交換資料的通訊。
我們在寫 socket programming 的時候會使用 os 提供的 API，來避免重複造輪子，今天的筆記會簡單介紹一下 linux 提供的 socket API，並用兩個簡單的範例介紹如何用 tcp 跟 udp 協定透過 socket 傳輸資料。
本文章所使用的環境
 kernel: 5.11.0-37-generic gcc version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 GNU Make: 4.2.1  在寫 socket 相關的程式的時候，需要先
#include &amp;lt;arpa/inet.h&amp;gt; // sockaddr 相關#include &amp;lt;sys/socket.h&amp;gt;socket int socket(int domain, int type, int protocol) domain 定義要建立哪一種類型的 socket，常用的有以下幾種類型
 AF_UNIX, AF_LOCAL: 用於本機間 process 的溝通 AF_INET, AF_INET6  AF_INET: IPv4 協定 AF_INET6: IPv6 協定    詳細的選項可以參考 socket 的 man page</description>
    </item>
    
    <item>
      <title>jserv - linux 核心設計 第一周題目二解題紀錄</title>
      <link>http://example.org/posts/jserv_linux_w1_q2/</link>
      <pubDate>Wed, 01 Sep 2021 01:04:53 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/jserv_linux_w1_q2/</guid>
      <description>單向 linked list
typedef struct __list { int data; struct __list *next; } list; 在不存在環狀結構的狀況下，以下函式能夠對 linked list 元素從小到大排序: 請補完 LL0 ~ LL6 程式碼。
list *sort(list *start) { if (!start || !start-&amp;gt;next) return start; list *left = start; list *right = left-&amp;gt;next; /* LL0; (a): left-&amp;gt;next = NULL; (b): right-&amp;gt;next = NULL; (c): left = left-&amp;gt;next; (d): left = right-&amp;gt;next; */ left = sort(left); right = sort(right); for (list *merge = NULL; left || right; ) { if (!</description>
    </item>
    
    <item>
      <title>Circular Doubly linked list 實作 bubble sort </title>
      <link>http://example.org/posts/cdll_bubblesort/</link>
      <pubDate>Wed, 25 Aug 2021 04:16:48 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/cdll_bubblesort/</guid>
      <description>前言 本問題出自於 jserv - Linux 核心設計講座 第一周 linked list 和非連續記憶體操作 底下題目一的延伸題目
在這篇文章會紀錄關於 bubble sort 的實現。
node 結構 struct node { int data; struct node *next, *prev; }; 本題目 linked list 屬於 circular doubly linked list, 所以處理上還需要考慮循環的問題。
swap 之後要把 node 的 prev 跟 next pointer 處理好。
Bubble sort void bubble_sort(int *arr, const int length) { for(int i = 0; i &amp;lt; length-1; i++) { int flag = 0; for(int j = 0; j &amp;lt; length-i-1; j++) { if(arr[j] &amp;gt; arr[j+1]) { int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t; flag = 1; } } if(!</description>
    </item>
    
    <item>
      <title>備份 vscode 環境紀錄</title>
      <link>http://example.org/posts/vscode_backup/</link>
      <pubDate>Sat, 21 Aug 2021 19:13:21 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/vscode_backup/</guid>
      <description>參考 將VS Code 工作環境備份到 GitHub上吧~
可以將 vscode 的環境快速複製到別台電腦，值得注意的是為了安全考量， github 的 token 最好期限設短一點，等備份完成之後就刪掉。</description>
    </item>
    
    <item>
      <title>golang cobra: 在沒有添加任何參數的情況下預設產生 help message</title>
      <link>http://example.org/posts/cobradefault/</link>
      <pubDate>Mon, 16 Aug 2021 01:37:36 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/cobradefault/</guid>
      <description>問題描述 最近在使用 cobra 編寫一個簡單的 command line 應用程式，過程中遇到一個之前都沒有想過的問題，把解決方式紀錄在這邊
一般來說用 cobra 寫的程式要顯示詳細的使用教學都要使用 --help 參數，如圖
但是我又想到 golangci-lint 這個工具同樣也是用 cobra 來寫 command line 的應用，卻可以在沒有添加參數的時候跳出 --help 的說明
像是這樣
所以我特別找了一些資料，發現其實解決的方法滿簡單的
解決方法 一般的教學文章在介紹 cobra 的時候都會訂一個 rootCmd 一類的物件，作為你的 command line 應用一開始的 root，之後的指令就會用
rootCmd.AddCommand(功能名稱) 的方式添加進去
所以解決方式很簡單，只要在 rootCmd 定義的地方判斷如果其 args 的長度為零，就呼叫預設的 Help function 即可。
var rootCmd = &amp;amp;cobra.Command{ Use: &amp;#34;leit&amp;#34;, Short: &amp;#34;A calendar application in command line.&amp;#34;, Long: doc, Run: func(cmd *cobra.Command, args []string) { if len(args) == 0 { _ = cmd.</description>
    </item>
    
    <item>
      <title>C Function Pointer 基礎用法整理</title>
      <link>http://example.org/posts/c_functionpointer/</link>
      <pubDate>Sun, 15 Aug 2021 00:04:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/c_functionpointer/</guid>
      <description>這最近在看 jserv 大神的 linux 核心設計講座，因為之前比較少寫 c，所以對於 function pointer 只有一點概念但沒有真正寫過，所以趁這個機會寫個筆記來紀錄一下用法。
之後在學習的過程中如果遇到 function pointer 的應用也會一併整理在這篇文章中。
function pointer function pointer 顧名思義就是指向某個 function 的 pointer，有了 function pointer 我們就可以實現把 function 當作參數，傳進一個 function 之中，或者更加彈性的設計我們的程式，減少多餘的 if/else, switch case。
我們先從一個簡單的 function pointer 宣告開始講起
int (*myFunc)(int, int); 上面就是一個基本的 function pointer 宣告
一個 function pointer 變數名稱為 myFunc，可以這麼解讀
 myFunc 是一個指標指向一個 function  該 function 有兩個 int 的 parameters 該 function 會回傳 int    假設今天我有個 function 宣告成以下這種形式
void parseFunc(float f1, int i1, char c1); 我們要怎麼宣告一個 pointer 去指向這個 function 呢？</description>
    </item>
    
    <item>
      <title>使用 Hugo 主題 LoveIt 架設 blog 資源紀錄</title>
      <link>http://example.org/posts/lovelt/</link>
      <pubDate>Fri, 13 Aug 2021 23:01:13 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/lovelt/</guid>
      <description>這次新架的 blog 使用了 LoveIt 這個主題
詳細的架設參數設定都是參考其官方部落格，寫的算是滿詳細的，值得參考。
至於跟 github page 連動的部份，這方面很多文章都有不同的解決方案，我在這篇分享一下我的解決方法。
因為 github page 只認得 docs 或者 public 兩個資料夾存放靜態檔案，所以我們勢必要把 hugo 生成的靜態檔案放到專案根目錄的 /docs 或者 /public 之中，底下是我 github page 專案的架構
其中 blog 是主要 hugo 生成的目錄，docs 是給 github page 辨識靜態檔案的目錄。
在 /blog 添加完新的文章之後，用指定目錄的方式，讓靜態檔案生成到 /docs 底下，讓 github page 讀取
hugo -d ../docs cd .. git add . git commit -m &amp;#34;update&amp;#34; git push reference  使用 GitHub Pages 展示你的 Single Page Application 使用 Github Pages 和 Hugo 搭建个人博客教程 使用hugo生成静态博客并部署在GitHub上 LoveIt 官方 blog  </description>
    </item>
    
    <item>
      <title>docker volume 用法整理</title>
      <link>http://example.org/posts/dockervolume/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/dockervolume/</guid>
      <description>因為 side project 可能會用簡單的資料庫，為了方便包成 docker 讓大家試玩，想要使用 Volume 的方式對資料庫做持久化。在這邊紀錄一下 Docker Volume 相關的一些用法。
 很多篇文章都不推薦使用 docker 存放資料庫，我也認為 Volume 比較適合使用在本地端或者非生產環境的小專案上。
 Volume 是什麼 Volume 可以想成一個可供單個或多個容器使用的特殊目錄，有以下特性:
 Volume 可以在容器間共享資源，檔案 更新 Volume 內的檔案並不會影響 Image Volume 會持續存在，並不會隨著容器刪除而消失  有點類似 Linux 底下的掛載，Image 中被指定掛載的目錄/檔案會複製到 Volume 中。
創建 Volume ~$ docker volume create volume_name  查看所有 Volume  ~$ docker volume ls  查看指定 Volume 資料  ~$ docker volume inspect volume_name 運行一個掛載 Volume 的 Container ~$ docker run -d -P \  --name web \  # -v my-vol:/usr/share/nginx/html \ --mount source=v1,target=/usr/share/nginx/html \  nginx:alpine 在使用 docker run 指令的時候可以使用 --mount 參數來將創建好的 Volume 掛載到容器內部，一次 docker run 可以掛載多個 Volume。</description>
    </item>
    
    <item>
      <title>Linux shell 變數相關用法整理(一): assign, echo, export, unset</title>
      <link>http://example.org/posts/linux_shell_var1/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/linux_shell_var1/</guid>
      <description>假設今天我們常用的資料夾路徑是在 /path1/workdir/project1/module... 每次登入 linux 環境都要切換到這個資料夾我們就需要重新輸入路徑
$ cd /path1/workdir/project1/module... 我們這時候就可以用一個變數來取代常用的字串
在這之前先介紹一下變數的取用
echo $ echo $HOME /home/davidlei $ echo ${HOME} /home/davidlei 取出 Home 這個變數的值並且顯示出來
 在 Linux 底下變數前面都需要加上 $ 符號來做辨識 也可以在 $ 符號後面用 {} 把變數名稱框起來
 回到一開始提到的案例，我們現在想要設置一個變數 work 來存放 /path/workdir/project1/module
$ echo $work // 還未設置的變數默認為空，echo 出來的結果是空 $ work=/path1/workdir/project1/module $ echo $work /path1/workdir/project1/module 變數的設定規則  設定變數中間以 &amp;ldquo;=&amp;rdquo; 連結，並且等號兩側不能有空格  $ var=something // 正確 $ var = something // 等號兩邊不得有空格 變數開頭不能是數字 變數內容含有空白字元可以用 &amp;quot;&amp;quot; 雙引號 或者 &#39;&#39; 單引號包起來    如果變數內容包含著其他變數，需要用 &amp;quot;&amp;quot; 包起來，請看下方範例 用 &#39;&#39; 包起來 bash 就不會把 $變數 置換成該變數的內容。</description>
    </item>
    
    <item>
      <title>Linux shell 變數相關用法整理(二): read, declare, array</title>
      <link>http://example.org/posts/linux_shell_var2/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/linux_shell_var2/</guid>
      <description>很多範例都是參考鳥哥的教材，再自己實際操作一次，文末有附上連結。
read 讀取從鍵盤輸入的變數，常常會出現在 shell script 之中
$ read [-pt] 變數名稱 // 參數 // -p 後面接提示字元 // -t 後面接等待時間，超過時間沒輸入則取消指令 $ declare 可以宣告變數的類型，我們上面提到有關變數的操作很多都只是單純的字串，但有些場合我們需要整數或者陣列時就要使用這個指令去指定變數的類型
$ declare [-aixr] 變數名稱 // 參數 // -a 宣告陣列型態的變數 // -i 宣告整數型態的變數 // -x 同 export 指令，宣告的變數變成全域變數(可以讓子程序讀取) // -r 宣告 readonly, 不可更改變數內容，也無法被 unset 取消 // -p 列出變數資料型態 $ 接著試著把 num 轉成全域變數，並且用 export 指令觀察一下:
列出指定變數的資料型態
array 以 arr[index]=content 的形式來指定 array Index 所代表的值。
reference  鳥哥的 Linux 私房菜  </description>
    </item>
    
    <item>
      <title>SDN 學習筆記(一): SDN 的發展歷史以及基本名詞介紹</title>
      <link>http://example.org/posts/sdn1/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/sdn1/</guid>
      <description>此專案用來整理一些學習 SDN 的相關知識以及參考資料。 由於剛開始學習沒多久，所以會著重於個人學習的順序，希望在寫心得的同時也可以幫助到一些想要研究 SDN 的朋友。
當然，由於我也是剛開始學習，所以整理的心得如果有誤也請各位前輩們指點
預備知識 在學習 SDN 之前我準備先複習了一輪 computer networking a top-down approach 7th，之前大學學過的很多部份已經有點忘記了，所以先把傳統的網路概論複習一輪，之後進入SDN的學習時，才會比較清楚知道為什麼要提出SDN的概念，SDN具體來說是要解決哪些傳統架構無法解決的問題。
之後會陸續整理一點網路的基礎理論心得，讓之後SDN的一些概念比較好解釋。
什麼是 SDN 以及 SDN 的發展歷史  參考文章
 SDN 簡介 SDN 發展趨勢   傳統網路的一些特點:
 每個節點是由設備單獨控制，屬於分散式架構。 控制面以及轉接面放在同一個設備上。 管理員無法直接的操作封包轉送行為，僅能控制設備的通訊協定，再藉由通訊協定的規則去操作設備。 通訊協定對於設備的影響是固定的，無法控制非自己協定內的規則。  SDN 想要採取集中式控制，要求轉接面跟控制面分離，實際上由遠端的 controller 計算以及分送每一個路由器的轉送表，管理員可以直接操作設備轉接封包的行為。
SDN 並非一種技術，而是一種設計的理念，只要符合控制面以及轉接面的分離，以及開放的可程式化設計界面，就可以稱為 SDN 架構。通常 SDN 也伴隨著集中控制的特性，藉由在 controller 獲得的網路全局資料(並非傳統只能獲得局部資料)，根據其業務邏輯進行調整及優化。
常用名詞解釋 Network Device 網路設備 網路設備不僅限於實體的設備(例如 switch ,路由器等等)，也有可能是虛擬的 switch (例如 OVS)，封包在網路設備之前被處理以及轉送。網路設備藉由 Southbound Interface 接收 controller 發過來的指令配置轉送的規則，也可以透過 Southbound Interface 來將一些資料回傳給 controller。</description>
    </item>
    
    <item>
      <title>SDN 學習筆記(二): OpenFlow 1.0 介紹</title>
      <link>http://example.org/posts/sdn2/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/sdn2/</guid>
      <description>前言 想要深入了解一個協定的內容，看規格書是最快的，因為剛開始學習 SDN 相關的知識，所以目前正在讀OpenFlow1.0相關的內容，這篇文章會先主要介紹OpenFlow 1.0的架構，以及一些 spec 的整理.
之後也會整理一些 OpenFlow 1.3版本的內容，並且簡單描述跟 OpenFlow 1.0的差異。
為什麼會著重在1.0與1.3兩個版本呢？  1.0版本與之後的版本不兼容，所以1.0要最先介紹。 1.0以及1.3版本被選為長期支持的穩定版本 1.3為目前的主流版本，多數支持OpenFlow的硬體是支援OpenFlow1.3
參考資料: OpenFlow 協定演進
 OpenFlow 1.0 架構 OpenFlow 1.0 spec 架構圖
 Flow Table 在 OpenFlow Switch 中存放轉發規則的表稱之為 Flow Table
 OpenFlow 1.0 中每個Switch只能存放一個Flow Table
 Flow Table中每個項目被稱為 Flow Entry 在 OpenFlow 1.0 中，每個 Flow Entry 中都包含三個部份
 Header Fields Counters Actions  Header Fields OpenFlow 1.0 協定中共有12種可供匹配的條件， IP部份只支援IPv4。
分別如下，僅列出條列，細節說明請參考 OpenFlow 1.0 spec</description>
    </item>
    
    <item>
      <title>The Google File System (GFS) 論文心得</title>
      <link>http://example.org/posts/gfs/</link>
      <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
      <author>davidleitw@gmail.com (davidlei)</author>
      <guid>http://example.org/posts/gfs/</guid>
      <description>跟著 MIT6.824 的課程進度， 在 Lec3 終於拜讀了這篇經典的論文，GFS 是一個分散式的檔案系統，由 Google 開發。 在2003年時 Google 發表了 The Google File System 這篇論文來分享一些 GFS 開發上的細節， 雖然 Google 沒有開源這個著名的檔案系統， 不過還是可以由 paper 來窺探當初 Google 設計的細節以及整體的架構。
背景 為了滿足當初 Google 日漸增長的資料處理需求， Google開發了 GFS 這套分散式檔案系統。
 用分散式的原因: 要處理的檔案大小已經遠遠超過單機可以容納的資料量
 跟過往很多分散式系統一樣，GFS 也追求著以下幾點需求:
 performance 性能 scalability 擴展性 reliability 可靠性 availability 可用性  因為成本以及其他因素的考量之下，Google 並沒有選擇商業用的 server 來製作 GFS 這套系統， 而且採用一般的 普通主機(inexpensive commidity hardware) 來作為叢集成員。因為是普通的主機，所以沒有商業用的 server 穩定， 在設計 GFS 的時候必須一併考慮容錯問題來增加穩定性。
在 Introduction 中也有先簡單介紹了 GFS 的幾個特色</description>
    </item>
    
  </channel>
</rss>
