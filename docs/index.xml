<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>davidLei</title>
        <link>http://example.org/</link>
        <description>一個紀錄心情，技術，人生的網站</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>davidleitw@gmail.com (davidlei)</managingEditor>
            <webMaster>davidleitw@gmail.com (davidlei)</webMaster><lastBuildDate>Wed, 27 Oct 2021 01:04:53 &#43;0800</lastBuildDate>
            <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>leetcode 222. Count Complete Tree Nodes</title>
    <link>http://example.org/posts/lc222/</link>
    <pubDate>Wed, 27 Oct 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lc222/</guid>
    <description><![CDATA[題目連結
題目敘述 給予一棵 Complete Binary Tree，求節點個數。
Complete Binary Tree 定義 BFS 用最直觀的 BFS 來解，每從 queue 拿出一個節點，count 加一。
class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; int cnt = 0; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { TreeNode *node = q.front(); q.pop(); if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); cnt++; } return cnt; } }; Runtime: 24 ms, faster than 95.34% of C++ online submissions for Count Complete Tree Nodes.]]></description>
</item><item>
    <title>linux socket programming(二): socket 中用來存放地址的 sockaddr</title>
    <link>http://example.org/posts/socker2/</link>
    <pubDate>Tue, 26 Oct 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/socker2/</guid>
    <description><![CDATA[sockaddr sockaddr 是 socket 的通用地址結構，就如同一開始提到的，socket 除了在網路領域之外，也可以在很多不同的地方用來通訊。
sockaddr 結構，定義如下
typedef unsigned short int sa_family_t; #define	__SOCKADDR_COMMON(sa_prefix) \ sa_family_t sa_prefix##family  struct sockaddr { __SOCKADDR_COMMON (sa_);	/* Common data: address family and length. */ char sa_data[14];	/* Address data. */ }; // 上面的結構把巨集展開後，等價於下方的資料結構 struct sockaddr { unsigned short int sa_family; // 2 bytes  char sa_data[14]; // 14 bytes }; 後來的更新中，為了讓龐大的程式碼可讀性上升，新增了 sockaddr_in 的結構用來存取網路相關的應用， in 指的是 internet，sockaddr_in 專門用來存 IPv4 的相關地址。
IPv6 則是使用 sockaddr_in6 結構，在本文章主要會著重在 IPv4 相關的範例。]]></description>
</item><item>
    <title>linux socket programming(一): 什麼是 socket &amp; 創建一個新的 socket</title>
    <link>http://example.org/posts/socket1/</link>
    <pubDate>Mon, 25 Oct 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/socket1/</guid>
    <description><![CDATA[socket programming socket 本質上是一種 IPC (Inter-Process Communication) 的技術，用於兩個或多個 process 進行資料交換或者通訊。
在網路領域，socket 著重的不是同一台主機間 process 的通訊，而是不同主機執行的 process 互相交換資料的通訊。
我們在寫 socket programming 的時候會使用 os 提供的 API，來避免重複造輪子，今天的筆記會簡單介紹一下 linux 提供的 socket API，並用兩個簡單的範例介紹如何用 tcp 跟 udp 協定透過 socket 傳輸資料。
本文章所使用的環境
 kernel: 5.11.0-37-generic gcc version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 GNU Make: 4.2.1  在寫 socket 相關的程式的時候，需要先
#include &lt;arpa/inet.h&gt; // sockaddr 相關#include &lt;sys/socket.h&gt;socket int socket(int domain, int type, int protocol) domain 定義要建立哪一種類型的 socket，常用的有以下幾種類型
 AF_UNIX, AF_LOCAL: 用於本機間 process 的溝通 AF_INET, AF_INET6  AF_INET: IPv4 協定 AF_INET6: IPv6 協定    詳細的選項可以參考 socket 的 man page]]></description>
</item><item>
    <title>jserv - linux 核心設計 第一周題目二解題紀錄</title>
    <link>http://example.org/posts/jserv_linux_w1_q2/</link>
    <pubDate>Wed, 01 Sep 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/jserv_linux_w1_q2/</guid>
    <description><![CDATA[單向 linked list
typedef struct __list { int data; struct __list *next; } list; 在不存在環狀結構的狀況下，以下函式能夠對 linked list 元素從小到大排序: 請補完 LL0 ~ LL6 程式碼。
list *sort(list *start) { if (!start || !start-&gt;next) return start; list *left = start; list *right = left-&gt;next; /* LL0; (a): left-&gt;next = NULL; (b): right-&gt;next = NULL; (c): left = left-&gt;next; (d): left = right-&gt;next; */ left = sort(left); right = sort(right); for (list *merge = NULL; left || right; ) { if (!]]></description>
</item><item>
    <title>Circular Doubly linked list 實作 bubble sort </title>
    <link>http://example.org/posts/cdll_bubblesort/</link>
    <pubDate>Wed, 25 Aug 2021 04:16:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/cdll_bubblesort/</guid>
    <description><![CDATA[前言 本問題出自於 jserv - Linux 核心設計講座 第一周 linked list 和非連續記憶體操作 底下題目一的延伸題目
在這篇文章會紀錄關於 bubble sort 的實現。
node 結構 struct node { int data; struct node *next, *prev; }; 本題目 linked list 屬於 circular doubly linked list, 所以處理上還需要考慮循環的問題。
swap 之後要把 node 的 prev 跟 next pointer 處理好。
Bubble sort void bubble_sort(int *arr, const int length) { for(int i = 0; i &lt; length-1; i++) { int flag = 0; for(int j = 0; j &lt; length-i-1; j++) { if(arr[j] &gt; arr[j+1]) { int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t; flag = 1; } } if(!]]></description>
</item><item>
    <title>備份 vscode 環境紀錄</title>
    <link>http://example.org/posts/vscode_backup/</link>
    <pubDate>Sat, 21 Aug 2021 19:13:21 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/vscode_backup/</guid>
    <description><![CDATA[參考 將VS Code 工作環境備份到 GitHub上吧~
可以將 vscode 的環境快速複製到別台電腦，值得注意的是為了安全考量， github 的 token 最好期限設短一點，等備份完成之後就刪掉。]]></description>
</item><item>
    <title>golang cobra: 在沒有添加任何參數的情況下預設產生 help message</title>
    <link>http://example.org/posts/cobradefault/</link>
    <pubDate>Mon, 16 Aug 2021 01:37:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/cobradefault/</guid>
    <description><![CDATA[問題描述 最近在使用 cobra 編寫一個簡單的 command line 應用程式，過程中遇到一個之前都沒有想過的問題，把解決方式紀錄在這邊
一般來說用 cobra 寫的程式要顯示詳細的使用教學都要使用 --help 參數，如圖
但是我又想到 golangci-lint 這個工具同樣也是用 cobra 來寫 command line 的應用，卻可以在沒有添加參數的時候跳出 --help 的說明
像是這樣
所以我特別找了一些資料，發現其實解決的方法滿簡單的
解決方法 一般的教學文章在介紹 cobra 的時候都會訂一個 rootCmd 一類的物件，作為你的 command line 應用一開始的 root，之後的指令就會用
rootCmd.AddCommand(功能名稱) 的方式添加進去
所以解決方式很簡單，只要在 rootCmd 定義的地方判斷如果其 args 的長度為零，就呼叫預設的 Help function 即可。
var rootCmd = &amp;cobra.Command{ Use: &#34;leit&#34;, Short: &#34;A calendar application in command line.&#34;, Long: doc, Run: func(cmd *cobra.Command, args []string) { if len(args) == 0 { _ = cmd.]]></description>
</item><item>
    <title>C Function Pointer 基礎用法整理</title>
    <link>http://example.org/posts/c_functionpointer/</link>
    <pubDate>Sun, 15 Aug 2021 00:04:43 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/c_functionpointer/</guid>
    <description><![CDATA[這最近在看 jserv 大神的 linux 核心設計講座，因為之前比較少寫 c，所以對於 function pointer 只有一點概念但沒有真正寫過，所以趁這個機會寫個筆記來紀錄一下用法。
之後在學習的過程中如果遇到 function pointer 的應用也會一併整理在這篇文章中。
function pointer function pointer 顧名思義就是指向某個 function 的 pointer，有了 function pointer 我們就可以實現把 function 當作參數，傳進一個 function 之中，或者更加彈性的設計我們的程式，減少多餘的 if/else, switch case。
我們先從一個簡單的 function pointer 宣告開始講起
int (*myFunc)(int, int); 上面就是一個基本的 function pointer 宣告
一個 function pointer 變數名稱為 myFunc，可以這麼解讀
 myFunc 是一個指標指向一個 function  該 function 有兩個 int 的 parameters 該 function 會回傳 int    假設今天我有個 function 宣告成以下這種形式
void parseFunc(float f1, int i1, char c1); 我們要怎麼宣告一個 pointer 去指向這個 function 呢？]]></description>
</item><item>
    <title>使用 Hugo 主題 LoveIt 架設 blog 資源紀錄</title>
    <link>http://example.org/posts/lovelt/</link>
    <pubDate>Fri, 13 Aug 2021 23:01:13 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/lovelt/</guid>
    <description><![CDATA[這次新架的 blog 使用了 LoveIt 這個主題
詳細的架設參數設定都是參考其官方部落格，寫的算是滿詳細的，值得參考。
至於跟 github page 連動的部份，這方面很多文章都有不同的解決方案，我在這篇分享一下我的解決方法。
因為 github page 只認得 docs 或者 public 兩個資料夾存放靜態檔案，所以我們勢必要把 hugo 生成的靜態檔案放到專案根目錄的 /docs 或者 /public 之中，底下是我 github page 專案的架構
其中 blog 是主要 hugo 生成的目錄，docs 是給 github page 辨識靜態檔案的目錄。
在 /blog 添加完新的文章之後，用指定目錄的方式，讓靜態檔案生成到 /docs 底下，讓 github page 讀取
hugo -d ../docs cd .. git add . git commit -m &#34;update&#34; git push reference  使用 GitHub Pages 展示你的 Single Page Application 使用 Github Pages 和 Hugo 搭建个人博客教程 使用hugo生成静态博客并部署在GitHub上 LoveIt 官方 blog  ]]></description>
</item><item>
    <title>docker volume 用法整理</title>
    <link>http://example.org/posts/dockervolume/</link>
    <pubDate>Fri, 13 Aug 2021 21:34:43 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/dockervolume/</guid>
    <description><![CDATA[因為 side project 可能會用簡單的資料庫，為了方便包成 docker 讓大家試玩，想要使用 Volume 的方式對資料庫做持久化。在這邊紀錄一下 Docker Volume 相關的一些用法。
 很多篇文章都不推薦使用 docker 存放資料庫，我也認為 Volume 比較適合使用在本地端或者非生產環境的小專案上。
 Volume 是什麼 Volume 可以想成一個可供單個或多個容器使用的特殊目錄，有以下特性:
 Volume 可以在容器間共享資源，檔案 更新 Volume 內的檔案並不會影響 Image Volume 會持續存在，並不會隨著容器刪除而消失  有點類似 Linux 底下的掛載，Image 中被指定掛載的目錄/檔案會複製到 Volume 中。
創建 Volume ~$ docker volume create volume_name  查看所有 Volume  ~$ docker volume ls  查看指定 Volume 資料  ~$ docker volume inspect volume_name 運行一個掛載 Volume 的 Container ~$ docker run -d -P \  --name web \  # -v my-vol:/usr/share/nginx/html \ --mount source=v1,target=/usr/share/nginx/html \  nginx:alpine 在使用 docker run 指令的時候可以使用 --mount 參數來將創建好的 Volume 掛載到容器內部，一次 docker run 可以掛載多個 Volume。]]></description>
</item></channel>
</rss>
