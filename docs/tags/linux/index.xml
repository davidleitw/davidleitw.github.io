<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>linux - Tag - davidLei</title>
        <link>http://example.org/tags/linux/</link>
        <description>linux - Tag - davidLei</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>davidleitw@gmail.com (davidlei)</managingEditor>
            <webMaster>davidleitw@gmail.com (davidlei)</webMaster><lastBuildDate>Tue, 28 Dec 2021 01:05:53 &#43;0800</lastBuildDate><atom:link href="http://example.org/tags/linux/" rel="self" type="application/rss+xml" /><item>
    <title>利用 vargrant 執行自己編譯的 kernel，快速搭建實驗環境</title>
    <link>http://example.org/posts/vagrant_001/</link>
    <pubDate>Tue, 28 Dec 2021 01:05:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/vagrant_001/</guid>
    <description><![CDATA[vagrant vagrant 是一款建立及管理虛擬機的工具，利用 vagrant 可以快速在本機端架設實驗環境，並且可以把自己習慣的環境包裝後在任何有安裝 vagrant 的電腦執行，達到 IaC(Infrastructure as Code) 的特性，使用 vagrant 可以大幅降低環境的架設時間，趁這個機會順便學習一下基本的用法。
這學期在修 linux 的課程會有添加 system call 或者改 kernel 的需求，所以這篇文章紀錄一下如何使用 vagrant 來執行自己編譯好的 kernel，以及一些 vagrant 的基本用法，用虛擬機做實驗也降低了把自己的環境搞壞的風險。
install 安裝可以參考 官方網站，在 ubuntu 的環境安裝 vagrant 可以用以下指令:
$ curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - $ sudo apt-add-repository &#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main&#34; $ sudo apt-get update &amp;&amp; sudo apt-get install vagrant $ vagrant plugin install vagrant-vbguest vagrant 只是一個管理虛擬機的工具，底層可以選擇 VirtualBox, VMware, AWS.. 等不同的虛擬機環境，在 linux 的主機中最方便安裝的就是 VirtualBox，所以在正式使用之前要記得先安裝 VirtualBox。]]></description>
</item><item>
    <title>linux socket programming(三): socket programming 中常用的位置轉換函數</title>
    <link>http://example.org/posts/socket3/</link>
    <pubDate>Fri, 12 Nov 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/socket3/</guid>
    <description><![CDATA[一般我們在表示 ip 位置時都會寫成人類比較容易讀的形式，像是125.102.25.62
以 ipv4 來說，address 是由4個 byte，32個 bit所組成，在實務上我們常常需要做字串與實際數值(uint32_t)的轉換，linux 函式庫提供了一系列輔助位置轉換的 function。
一般來說，address 的實際數值都會用 in_addr 或者 in_addr_t 來表示 其本質就是 uint32_t，用總共 32 個 bits 來表示一個 IPv4 的地址
typedef uint32_t in_addr_t; // 4 byte struct in_addr { in_addr_t s_addr; }; 常用的有以下這五種
 只能用在 IPv4 的處理  inet_addr inet_aton inet_ntoa   兼容 Ipv4 與 IPv6  inet_pton inet_ntop    使用前必須先
#include &lt;arpa/inet.h&gt;inet_addr in_addr_t inet_addr(const char *cp) 功能: 將字串轉換成數值表示的 ip address
回傳: 假如輸入的地址合法，會回傳 uint32_t 的數值，若不合法則回傳 INADDR_NONE]]></description>
</item><item>
    <title>linux socket programming(二): socket 中用來存放地址的 sockaddr</title>
    <link>http://example.org/posts/socker2/</link>
    <pubDate>Tue, 26 Oct 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/socker2/</guid>
    <description><![CDATA[sockaddr sockaddr 是 socket 的通用地址結構，就如同一開始提到的，socket 除了在網路領域之外，也可以在很多不同的地方用來通訊。
sockaddr 結構，定義如下
typedef unsigned short int sa_family_t; #define	__SOCKADDR_COMMON(sa_prefix) \ sa_family_t sa_prefix##family  struct sockaddr { __SOCKADDR_COMMON (sa_);	/* Common data: address family and length. */ char sa_data[14];	/* Address data. */ }; // 上面的結構把巨集展開後，等價於下方的資料結構 struct sockaddr { unsigned short int sa_family; // 2 bytes  char sa_data[14]; // 14 bytes }; 後來的更新中，為了讓龐大的程式碼可讀性上升，新增了 sockaddr_in 的結構用來存取網路相關的應用， in 指的是 internet，sockaddr_in 專門用來存 IPv4 的相關地址。
IPv6 則是使用 sockaddr_in6 結構，在本文章主要會著重在 IPv4 相關的範例。]]></description>
</item><item>
    <title>linux socket programming(一): 什麼是 socket &amp; 創建一個新的 socket</title>
    <link>http://example.org/posts/socket1/</link>
    <pubDate>Mon, 25 Oct 2021 01:04:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/socket1/</guid>
    <description><![CDATA[socket programming socket 本質上是一種 IPC (Inter-Process Communication) 的技術，用於兩個或多個 process 進行資料交換或者通訊。
在網路領域，socket 著重的不是同一台主機間 process 的通訊，而是不同主機執行的 process 互相交換資料的通訊。
我們在寫 socket programming 的時候會使用 os 提供的 API，來避免重複造輪子，今天的筆記會簡單介紹一下 linux 提供的 socket API，並用兩個簡單的範例介紹如何用 tcp 跟 udp 協定透過 socket 傳輸資料。
本文章所使用的環境
 kernel: 5.11.0-37-generic gcc version: gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 GNU Make: 4.2.1  在寫 socket 相關的程式的時候，需要先
#include &lt;arpa/inet.h&gt; // sockaddr 相關#include &lt;sys/socket.h&gt;socket int socket(int domain, int type, int protocol) domain 定義要建立哪一種類型的 socket，常用的有以下幾種類型
 AF_UNIX, AF_LOCAL: 用於本機間 process 的溝通 AF_INET, AF_INET6  AF_INET: IPv4 協定 AF_INET6: IPv6 協定    詳細的選項可以參考 socket 的 man page]]></description>
</item><item>
    <title>Linux shell 變數相關用法整理(一): assign, echo, export, unset</title>
    <link>http://example.org/posts/linux_shell_var1/</link>
    <pubDate>Fri, 13 Aug 2021 21:34:43 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/linux_shell_var1/</guid>
    <description><![CDATA[假設今天我們常用的資料夾路徑是在 /path1/workdir/project1/module... 每次登入 linux 環境都要切換到這個資料夾我們就需要重新輸入路徑
$ cd /path1/workdir/project1/module... 我們這時候就可以用一個變數來取代常用的字串
在這之前先介紹一下變數的取用
echo $ echo $HOME /home/davidlei $ echo ${HOME} /home/davidlei 取出 Home 這個變數的值並且顯示出來
 在 Linux 底下變數前面都需要加上 $ 符號來做辨識 也可以在 $ 符號後面用 {} 把變數名稱框起來
 回到一開始提到的案例，我們現在想要設置一個變數 work 來存放 /path/workdir/project1/module
$ echo $work // 還未設置的變數默認為空，echo 出來的結果是空 $ work=/path1/workdir/project1/module $ echo $work /path1/workdir/project1/module 變數的設定規則  設定變數中間以 &ldquo;=&rdquo; 連結，並且等號兩側不能有空格  $ var=something // 正確 $ var = something // 等號兩邊不得有空格 變數開頭不能是數字 變數內容含有空白字元可以用 &quot;&quot; 雙引號 或者 '' 單引號包起來    如果變數內容包含著其他變數，需要用 &quot;&quot; 包起來，請看下方範例 用 '' 包起來 bash 就不會把 $變數 置換成該變數的內容。]]></description>
</item><item>
    <title>Linux shell 變數相關用法整理(二): read, declare, array</title>
    <link>http://example.org/posts/linux_shell_var2/</link>
    <pubDate>Fri, 13 Aug 2021 21:34:43 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/linux_shell_var2/</guid>
    <description><![CDATA[很多範例都是參考鳥哥的教材，再自己實際操作一次，文末有附上連結。
read 讀取從鍵盤輸入的變數，常常會出現在 shell script 之中
$ read [-pt] 變數名稱 // 參數 // -p 後面接提示字元 // -t 後面接等待時間，超過時間沒輸入則取消指令 $ declare 可以宣告變數的類型，我們上面提到有關變數的操作很多都只是單純的字串，但有些場合我們需要整數或者陣列時就要使用這個指令去指定變數的類型
$ declare [-aixr] 變數名稱 // 參數 // -a 宣告陣列型態的變數 // -i 宣告整數型態的變數 // -x 同 export 指令，宣告的變數變成全域變數(可以讓子程序讀取) // -r 宣告 readonly, 不可更改變數內容，也無法被 unset 取消 // -p 列出變數資料型態 $ 接著試著把 num 轉成全域變數，並且用 export 指令觀察一下:
列出指定變數的資料型態
array 以 arr[index]=content 的形式來指定 array Index 所代表的值。
reference  鳥哥的 Linux 私房菜  ]]></description>
</item></channel>
</rss>
