<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Container on davidLei</title>
        <link>https://davidleitw.github.io/tags/container/</link>
        <description>Recent content in Container on davidLei</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <copyright>davidlei</copyright>
        <lastBuildDate>Wed, 04 May 2022 00:01:01 +0800</lastBuildDate><atom:link href="https://davidleitw.github.io/tags/container/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Docker 網路模型與 Linux namespace, bridge 機制探討</title>
        <link>https://davidleitw.github.io/p/docker-%E7%B6%B2%E8%B7%AF%E6%A8%A1%E5%9E%8B%E8%88%87-linux-namespace-bridge-%E6%A9%9F%E5%88%B6%E6%8E%A2%E8%A8%8E/</link>
        <pubDate>Wed, 04 May 2022 00:01:01 +0800</pubDate>
        
        <guid>https://davidleitw.github.io/p/docker-%E7%B6%B2%E8%B7%AF%E6%A8%A1%E5%9E%8B%E8%88%87-linux-namespace-bridge-%E6%A9%9F%E5%88%B6%E6%8E%A2%E8%A8%8E/</guid>
        <description>&lt;p&gt;在 Container 中最重要的一個特性就是資源的隔離，在 Linux 中透過 namespace 提供不同資源的隔離機制，這篇文章會特別探討其中出現最頻繁的 network 的隔離機制，並且透過簡單的實驗來觀察 Docker 的網路模型是怎麼透過 namespace 實現的。&lt;/p&gt;
&lt;h2 id=&#34;network-namespace&#34;&gt;&lt;a href=&#34;#network-namespace&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Network Namespace
&lt;/h2&gt;&lt;p&gt;在 command line 操作 network namespace 通常會使用 &lt;code&gt;ip netns&lt;/code&gt; 來操作，先引用 &lt;code&gt;ip-netns&lt;/code&gt; 的 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man8/ip-netns.8.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;man page&lt;/a&gt; 來介紹一下 network namespace 的定義&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A network namespace is logically another copy of the network stack, with its own routes, firewall rules, and network devices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以查看 &lt;a class=&#34;link&#34; href=&#34;https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NETWORK_NAMESPACES(7)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DHg0aoM.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因為 network namespace 本身隔離了整個 network stack, 所以幾乎所有關於 network 的資源都會被隔離，每個 namespace 內這些資源都是獨立存在的。&lt;/p&gt;
&lt;p&gt;如果有牽涉到 &lt;code&gt;fork()&lt;/code&gt; 等建立新的 process 的行為，原則上 child process 會繼承 parent 的 network space。&lt;/p&gt;
&lt;p&gt;一開始可以用 &lt;code&gt;ip netns help&lt;/code&gt; 來查看大概有哪些指令可以使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3FdIjWB.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;建立新的-network-namespace&#34;&gt;&lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e6%96%b0%e7%9a%84-network-namespace&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;建立新的 network namespace
&lt;/h3&gt;&lt;p&gt;建立一個新的 network namespace 可以使用 &lt;code&gt;sudo ip netns add&lt;/code&gt; 加上想要的 namespace 名稱，建立之後用 &lt;code&gt;ip netns ls&lt;/code&gt; 就可以看到多了一個剛剛建立的 network namespace。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add ns0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ip netns ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;ip netns&lt;/code&gt; 建立的 network namespace 會出現在 &lt;code&gt;/var/run/netns&lt;/code&gt; 底下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9suVUf7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在本地端我們常常會使用 &lt;code&gt;ifconfig&lt;/code&gt; 或者 &lt;code&gt;ip addr&lt;/code&gt; 來檢查一些網路的配置情況，所以 &lt;code&gt;ip netns&lt;/code&gt; 工具為了讓我們更方便的操作，提供了 &lt;code&gt;ip netns exec&lt;/code&gt; 的子命令讓我們可以在對應的 network namespace 執行命令，我們下面的幾個範例都會使用剛剛建立的 &lt;code&gt;ns0&lt;/code&gt; 來操作，先來看看在 &lt;code&gt;ns0&lt;/code&gt; 中執行 &lt;code&gt;ifconfig&lt;/code&gt; 或者 &lt;code&gt;ip addr&lt;/code&gt; 的情況。&lt;/p&gt;
&lt;h3 id=&#34;執行-cmd-在特定的-network-namespace&#34;&gt;&lt;a href=&#34;#%e5%9f%b7%e8%a1%8c-cmd-%e5%9c%a8%e7%89%b9%e5%ae%9a%e7%9a%84-network-namespace&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;執行 cmd 在特定的 network namespace
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ip netns exec &amp;lt;network namespace name&amp;gt; + cmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/QSffLmE.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以觀察到，新建立的 &lt;code&gt;ns0&lt;/code&gt; 目前只有預設的 &lt;code&gt;lo (loopback interface)&lt;/code&gt;，這個 &lt;code&gt;lo&lt;/code&gt; 也可以說是 &lt;code&gt;localhost&lt;/code&gt; 的虛擬網路 interface。&lt;/p&gt;
&lt;p&gt;想要了解更多可以參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/hustcat/p/3920940.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;這篇文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://askubuntu.com/questions/247625/what-is-the-loopback-device-and-how-do-i-use-it&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What is the loopback device and how do I use it?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;veth---virtual-ethernet-device&#34;&gt;&lt;a href=&#34;#veth---virtual-ethernet-device&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;veth - Virtual Ethernet Device
&lt;/h2&gt;&lt;p&gt;Linux 中有 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man4/veth.4.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;veth - Virtual Ethernet Device&lt;/a&gt; 的概念， &lt;code&gt;veth&lt;/code&gt; 可以拿來建立不同虛擬網路裝置之間的橋樑，讓不同虛擬裝置之間可以連線，像是不同的 network namespace，又或者是 docker container 之間的連線, ovs 內的應用等等，都有使用到 &lt;code&gt;veth&lt;/code&gt; 的概念。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;veth&lt;/code&gt; 都是成對出現的，所以很多文章也把它稱為 &lt;code&gt;veth-pair&lt;/code&gt;，在後續的實驗中我們也可以觀察到 Docker 彼此之間的 &lt;code&gt;veth-pair&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;為了實驗兩個 network namespace 的連線，我們再建立一個 &lt;code&gt;ns1&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add ns1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ip netns ls
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ns1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ns0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;建立新的-veth-pair&#34;&gt;&lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e6%96%b0%e7%9a%84-veth-pair&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;建立新的 veth Pair
&lt;/h3&gt;&lt;p&gt;上面有提到 &lt;code&gt;veth&lt;/code&gt; 都是成對出現的，所以在建立的時候也要同時建立兩端，這邊我們將兩端分別取名 &lt;code&gt;vth0&lt;/code&gt; 以及 &lt;code&gt;vth1&lt;/code&gt; 代表等等要接在 &lt;code&gt;ns0&lt;/code&gt; 與 &lt;code&gt;ns1&lt;/code&gt; 上面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link add vth0 &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; veth peer vth1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ip link show
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接著用 &lt;code&gt;ip link show&lt;/code&gt; 就可以看到剛剛建立的 &lt;code&gt;veth pair&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KfnBEla.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;將-veth-連結到-network-namespace&#34;&gt;&lt;a href=&#34;#%e5%b0%87-veth-%e9%80%a3%e7%b5%90%e5%88%b0-network-namespace&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;將 veth 連結到 network namespace
&lt;/h3&gt;&lt;p&gt;建立好了兩端的 &lt;code&gt;veth&lt;/code&gt; 之後我們就需要把它接到對應的 network namespace&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; vth0 netns ns0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; vth1 netns ns2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;這時候我們再使用 &lt;code&gt;ip link show&lt;/code&gt; 確認一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Xxv9YDk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;發現剛剛建立的 &lt;code&gt;vth0&lt;/code&gt; 與 &lt;code&gt;vth1&lt;/code&gt; 不見了，因為我們已經把他們移動到新建立的 network namespace 之中，我們可以在 &lt;code&gt;ns0&lt;/code&gt; 與 &lt;code&gt;ns1&lt;/code&gt; 中用 &lt;code&gt;ip addr&lt;/code&gt; 觀察到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FoVEZnV.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;啟動-veth-並且分配一個私有的-ip&#34;&gt;&lt;a href=&#34;#%e5%95%9f%e5%8b%95-veth-%e4%b8%a6%e4%b8%94%e5%88%86%e9%85%8d%e4%b8%80%e5%80%8b%e7%a7%81%e6%9c%89%e7%9a%84-ip&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;啟動 veth 並且分配一個私有的 ip
&lt;/h3&gt;&lt;p&gt;光是把 &lt;code&gt;vth0&lt;/code&gt;, &lt;code&gt;vth1&lt;/code&gt; 連結到 &lt;code&gt;ns0&lt;/code&gt;, &lt;code&gt;ns1&lt;/code&gt; 還不夠，為了後續 ping 的實驗我們必須在 &lt;code&gt;ns0&lt;/code&gt;, &lt;code&gt;ns1&lt;/code&gt; 中啟動 &lt;code&gt;veth&lt;/code&gt; 並且分配一個私有的 ip 位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns0 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; vth0 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns0 ip addr add 172.0.0.2/24 dev vth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns1 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; vth1 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns1 ip addr add 172.0.0.3/24 dev vth1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我們為 &lt;code&gt;vth0&lt;/code&gt; 分配了 172.0.0.2/24，&lt;code&gt;vth1&lt;/code&gt; 分配了 172.0.0.3/24，我們一樣分別進入 &lt;code&gt;ns0&lt;/code&gt;, &lt;code&gt;ns1&lt;/code&gt; 用 &lt;code&gt;ip addr&lt;/code&gt; 確認他們對應的 &lt;code&gt;veth&lt;/code&gt; 是否開啟並且正確的被分配了 ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gz0Ro7m.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;經過一系列的操作之後我們現在的網路拓樸如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MhsCm9a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因為設置的 ip 在同一個網域下，而且也經過 &lt;code&gt;ip addr&lt;/code&gt; 確認綁定到 &lt;code&gt;veth&lt;/code&gt; 上，現在可以用 ping 指令發現兩個 network namespace 之間可以通了!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AgY7egp.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;用-bridge-串連多個不同的-namespace&#34;&gt;&lt;a href=&#34;#%e7%94%a8-bridge-%e4%b8%b2%e9%80%a3%e5%a4%9a%e5%80%8b%e4%b8%8d%e5%90%8c%e7%9a%84-namespace&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;用 bridge 串連多個不同的 namespace
&lt;/h2&gt;&lt;p&gt;上面的情境是兩個 network namespace 想要互相連結，但真實世界的網路拓樸通常都是多個不同的 device 要互相連結，這時候如果再用 &lt;code&gt;veth&lt;/code&gt; 一個一個設置就不切實際，在一般的網路環境我們會想到用 switch 一類的裝置處理，在 Linux 中也可以透過 &lt;code&gt;bridge&lt;/code&gt; 的概念，用類似虛擬 switch 的方式解決多個不同 network namespace 互連的場景。&lt;/p&gt;
&lt;p&gt;從頭開始，目標是建立 &lt;code&gt;ns0&lt;/code&gt;, &lt;code&gt;ns1&lt;/code&gt;, &lt;code&gt;ns2&lt;/code&gt; 三個 network namespace 並且讓他們可以透過 &lt;code&gt;bridge&lt;/code&gt;互相連結。&lt;/p&gt;
&lt;p&gt;最後目標的網路拓樸如下圖&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bC0mjXe.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;注意，這次我們有做一點調整，把 &lt;code&gt;veth&lt;/code&gt; 連結到 network namespace 之後統一改名成 &lt;code&gt;eth0&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;建立-bridge-device&#34;&gt;&lt;a href=&#34;#%e5%bb%ba%e7%ab%8b-bridge-device&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;建立 bridge device
&lt;/h3&gt;&lt;p&gt;先建立一個 &lt;code&gt;bridge device&lt;/code&gt; 並且取名為 &lt;code&gt;br0&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link add br0 &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; bridge
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; br0 up
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;建立三個 network namespace 以及建立三對 &lt;code&gt;veth-pair&lt;/code&gt; 分別對應 &lt;code&gt;ns0&lt;/code&gt;, &lt;code&gt;ns1&lt;/code&gt;, &lt;code&gt;ns2&lt;/code&gt; 連結到 &lt;code&gt;br0&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add ns0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add ns1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add ns2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link add &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; veth
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link add &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; veth
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link add &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; veth
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;這次換了一種建立方式，直接 &lt;code&gt;ip link add type veth&lt;/code&gt;，不用自己取名字，系統會幫你分配好，如下圖所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OB3MrnC.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;先處理對接 &lt;code&gt;br0&lt;/code&gt; 的部份，把 &lt;code&gt;veth0&lt;/code&gt;, &lt;code&gt;veth2&lt;/code&gt;, &lt;code&gt;veth4&lt;/code&gt; 連接到 &lt;code&gt;br0&lt;/code&gt;，一定要記得把他們 set up。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth0 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth0 master br0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth2 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth2 master br0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth4 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth4 master br0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接著處理對接到 network namespace 的部份&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 設置 ns0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth1 netns ns0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns0 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; veth1 name eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns0 ip addr add 10.0.0.1/24 dev eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns0 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; eth0 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 設置 ns1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev veth3 netns ns1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns1 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev veth3 name eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns1 ip addr add 10.0.0.2/24 dev eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns1 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev eth0 up
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 設置 ns2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev veth5 netns ns2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns2 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev veth5 name eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns2 ip addr add 10.0.0.3/24 dev eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; ns2 ip link &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt; dev eth0 up
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;設置好之後可以去每個 network namespace 用 &lt;code&gt;ip addr&lt;/code&gt; 查看是否設置完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HxAIpep.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以用 ping 測試是否成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/reV0urc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;正常來說會發現還是無法成功 ping&lt;/p&gt;
&lt;p&gt;這時候針對 &lt;code&gt;br0&lt;/code&gt; 改一下配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo iptables -A FORWARD -i br0 -j ACCEPT
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接著就可以測試，發現三個 network namespace 可以互通了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fZYLfQW.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker-network-drivers&#34;&gt;&lt;a href=&#34;#docker-network-drivers&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Docker network drivers
&lt;/h2&gt;&lt;p&gt;再來介紹完基礎的 network namespace, veth, bridge 之後我們再來看看 Docker 的網路模型。&lt;/p&gt;
&lt;p&gt;Docker 在設計的時候就提供了很多種不同的 Network drivers 可以替換，不同 Network drivers 代表著不同的網路模型，使用 &lt;code&gt;docker&lt;/code&gt; 指令建立容器時，可以透過 &lt;code&gt;--network&lt;/code&gt; 參數選擇想要的網路模型。&lt;/p&gt;
&lt;p&gt;大致上可以分為這幾種&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overlay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ipvlan&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;macvlan&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;none&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這篇文章主要會介紹 &lt;code&gt;bridge&lt;/code&gt; 模式，一方面是因為上面的範例也讓我們對於 Linux 的 bridge 機制有了初步的了解，另一方面是如果不特別選擇的話，Docker 預設的網路模型就是 &lt;code&gt;bridge&lt;/code&gt; 模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In terms of networking, a bridge network is a Link Layer device which forwards traffic between network segments. A bridge can be a hardware device or a software device running within a host machine’s kernel.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/network/bridge/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文檔&lt;/a&gt;中從定義開始介紹，&lt;code&gt;bridge network&lt;/code&gt; 專門用在同個網段(Network segmentation) 的流量轉發，&lt;code&gt;bridge&lt;/code&gt; 可以是硬體也可以是 kernel 的機制，前文中我們介紹的 bridge 就是 kernel 提供的 software device。&lt;/p&gt;
&lt;p&gt;在一開始安裝完 Docker 之後可以用 &lt;code&gt;ip addr&lt;/code&gt; 指令看到一個新的 &lt;code&gt;docker0&lt;/code&gt; 的裝置，這就是預設 &lt;code&gt;bridge&lt;/code&gt; 模式使用的 bridge，每次在建立新的容器的時候，預設情況 Docker 都會建立一個新的 network namespace，並且透過 &lt;code&gt;docker0&lt;/code&gt; 來彼此溝通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/l8FXB2A.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在實驗或者本地端執行的時候使用預設的網路模式很方便，但是在正式的環境往往會複雜許多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以使用 &lt;code&gt;docker network ls&lt;/code&gt; 來看到 driver 的 type 是 &lt;code&gt;bridge&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MJvRh3C.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;想繼續看 &lt;code&gt;bridge&lt;/code&gt; 的詳細資料可以使用 &lt;code&gt;docker network inspect bridge&lt;/code&gt;，可以看到 &lt;code&gt;bridge&lt;/code&gt; 的 &lt;code&gt;subnet&lt;/code&gt;, &lt;code&gt;gateway IP&lt;/code&gt; 等等更詳細的設定&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LYB4sEG.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;建立一個新的-container&#34;&gt;&lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e4%b8%80%e5%80%8b%e6%96%b0%e7%9a%84-container&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;建立一個新的 container
&lt;/h3&gt;&lt;p&gt;先建立一個 container 來試試預設的網路功能&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker run --name nginx_test1 -d -p 8081:80 nginx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker ps -a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;docker ps -a&lt;/code&gt; 確定 &lt;code&gt;nginx_test1&lt;/code&gt; 有跑起來&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bvwRulh.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;詳細資料可以使用 &lt;code&gt;docker inspect nginx_test1&lt;/code&gt; 來查看，注意最下面 &lt;code&gt;Networks&lt;/code&gt; 的地方，可以看到剛剛建立的 &lt;code&gt;nginx_test1&lt;/code&gt; 連結到預設的 &lt;code&gt;bridge&lt;/code&gt;，並且配了 &lt;code&gt;172.17.0.2&lt;/code&gt; 的 ip address 給它&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cKlyBb4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在建立 &lt;code&gt;nginx_test1&lt;/code&gt; 的時候有設定 &lt;code&gt;8081:80&lt;/code&gt; 的映射，所以打開瀏覽器訪問 &lt;code&gt;localhost:8081&lt;/code&gt; 應該可以看到 &lt;code&gt;nginx&lt;/code&gt; 的首頁&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kwOliZn.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;curl localhost:8081&lt;/code&gt; 也可以獲得正確的 html&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OtdrnLj.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我們再次確認 &lt;code&gt;bridge&lt;/code&gt; 的配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker inspect bridge
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KELXW9t.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可以注意到 &lt;code&gt;Containers&lt;/code&gt; 的地方多了剛剛建立的 &lt;code&gt;nginx_test1&lt;/code&gt; 的資料，代表說 &lt;code&gt;nginx_test1&lt;/code&gt; 是透過 &lt;code&gt;bridge&lt;/code&gt; 跟外部建立連線的，這也是為什麼剛剛可以訪問 &lt;code&gt;nginx_test1&lt;/code&gt; 的原因。&lt;/p&gt;
&lt;h3 id=&#34;兩個-containers-透過預設的-bridge-互連&#34;&gt;&lt;a href=&#34;#%e5%85%a9%e5%80%8b-containers-%e9%80%8f%e9%81%8e%e9%a0%90%e8%a8%ad%e7%9a%84-bridge-%e4%ba%92%e9%80%a3&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;兩個 containers 透過預設的 bridge 互連
&lt;/h3&gt;&lt;p&gt;接著來觀察在預設的網路環境， container 之間是否也可以藉由 &lt;code&gt;bridge&lt;/code&gt; 互連，先用 &lt;code&gt;alpine&lt;/code&gt; 的 image 建立兩個 container&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker run -dit --name a1 alpine ash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo docker run -dit --name a2 alpine ash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/f97aohR.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;確認 &lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;a2&lt;/code&gt; 的 ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OD0d2PV.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jmBZggO.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;code&gt;docker exec&lt;/code&gt; 進入 &lt;code&gt;a1&lt;/code&gt; 之後 ping &lt;code&gt;a2&lt;/code&gt; 還有 &lt;code&gt;8.8.8.8&lt;/code&gt; 試試看是否能連通隔壁的 &lt;code&gt;a2&lt;/code&gt; 還有實際的網路&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WAnNM09.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/xqhpuxc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因為前面已經介紹過 veth, network namespace 的概念了，所以可以來觀察一下在預設的模式中， docker 是如何把多個 container 連在一起，讓彼此可以連通&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ip addr
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8DDjgxS.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ip addr&lt;/code&gt; 發現多了兩個 veth 開頭的裝置，分別是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vethd1d03d7@1f5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;veth6e0f94d@if7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;veth&lt;/code&gt; 總是成對出現，所以這邊應該可以意識到這是 &lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;a2&lt;/code&gt; 與 &lt;code&gt;docker0&lt;/code&gt; 對接的 &lt;code&gt;veth&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接著進入 &lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;a2&lt;/code&gt; 對應的 &lt;code&gt;veth&lt;/code&gt; 裝置&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YG8Ru1b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;所以這邊可以畫出目前的網路拓樸&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dDqeeAL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在預設模式下，每個 container 都可以透過 &lt;code&gt;docker0&lt;/code&gt; 互連，也可以對外連線，那如果每個 container 都會建立一個新的 network namespace，使用 &lt;code&gt;ip netns ls&lt;/code&gt; 應該可以看到才對&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ip netns ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用 &lt;code&gt;ip netns ls&lt;/code&gt; 查詢的結果應該會是空的，上面有簡單提到，每個建立的 network namespace 都會在 &lt;code&gt;/var/run/netns&lt;/code&gt; 底下建立一個新的文件，但是 docker 特別建立了一個新的資料夾擺放建立 container 之後產生的 network namespace，在 &lt;code&gt;/var/run/docker/netns&lt;/code&gt; 底下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cyh3TVU.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;&lt;a href=&#34;#reference&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;reference
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hackmd.io/@0xff07/network/https%3A%2F%2Fhackmd.io%2F%400xff07%2FSJzOwViYF&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;計算機網路 - Network Namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cizixs.com/2017/02/10/network-virtualization-network-namespace/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 網路虛擬化: network namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/bakari/p/10443484.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文搞懂 Linux network namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000009491002&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 虛擬網路設備 - bridge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://azole.medium.com/docker-container-%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80%E7%AF%87-2-c14d8f852ae4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker Container 基礎入門篇 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hwchiu.com/docker-network-model-lab.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker 網路入門篇(二) - Bridge 網路模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>docker volume 用法整理</title>
        <link>https://davidleitw.github.io/p/docker-volume-%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86/</link>
        <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
        
        <guid>https://davidleitw.github.io/p/docker-volume-%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86/</guid>
        <description>&lt;p&gt;因為 side project 可能會用簡單的資料庫，為了方便包成 docker 讓大家試玩，想要使用 &lt;code&gt;Volume&lt;/code&gt; 的方式對資料庫做持久化。在這邊紀錄一下 &lt;code&gt;Docker Volume&lt;/code&gt; 相關的一些用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很多篇文章都不推薦使用 docker 存放資料庫，我也認為 Volume 比較適合使用在本地端或者非生產環境的小專案上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;volume-是什麼&#34;&gt;&lt;a href=&#34;#volume-%e6%98%af%e4%bb%80%e9%ba%bc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;code&gt;Volume&lt;/code&gt; 是什麼
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Volume&lt;/code&gt; 可以想成一個可供單個或多個容器使用的特殊目錄，有以下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Volume&lt;/code&gt; 可以在容器間共享資源，檔案&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;Volume&lt;/code&gt; 內的檔案並不會影響 Image&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Volume&lt;/code&gt; 會持續存在，並不會隨著容器刪除而消失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有點類似 Linux 底下的掛載，Image 中被指定掛載的目錄/檔案會複製到 &lt;code&gt;Volume&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2 id=&#34;創建-volume&#34;&gt;&lt;a href=&#34;#%e5%89%b5%e5%bb%ba-volume&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;創建 &lt;code&gt;Volume&lt;/code&gt;
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker volume create volume_name
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看所有 &lt;code&gt;Volume&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker volume ls
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看指定 &lt;code&gt;Volume&lt;/code&gt; 資料&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker volume inspect volume_name
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mRZ8bUN.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;運行一個掛載-volume-的-container&#34;&gt;&lt;a href=&#34;#%e9%81%8b%e8%a1%8c%e4%b8%80%e5%80%8b%e6%8e%9b%e8%bc%89-volume-%e7%9a%84-container&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;運行一個掛載 &lt;code&gt;Volume&lt;/code&gt; 的 Container
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker run -d -P &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --name web &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# -v my-vol:/usr/share/nginx/html \&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --mount &lt;span class=&#34;nv&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;v1,target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/share/nginx/html &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    nginx:alpine
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在使用 &lt;code&gt;docker run&lt;/code&gt; 指令的時候可以使用 &lt;code&gt;--mount&lt;/code&gt; 參數來將創建好的 &lt;code&gt;Volume&lt;/code&gt; 掛載到容器內部，一次 &lt;code&gt;docker run&lt;/code&gt; 可以掛載多個 &lt;code&gt;Volume&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 指的是要將容器內的哪一個檔案/資料夾綁定到 &lt;code&gt;Volume&lt;/code&gt; 上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker run 參數
&lt;ul&gt;
&lt;li&gt;-d: 背景執行 container&lt;/li&gt;
&lt;li&gt;-P: Publish all exposed ports to random ports&lt;/li&gt;
&lt;li&gt;&amp;ndash;name: container name&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;執行之後可以使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker inspect web
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以在 &lt;code&gt;Mounts&lt;/code&gt; 欄位底下找到 &lt;code&gt;Volume&lt;/code&gt; 的相關資料
&lt;img src=&#34;https://i.imgur.com/VvJ6lQi.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上述的操作通常用在 container 產生一些 data，我們想要讓那些 data 不會在 container 被刪除之後消失，做資料持久化的時候才會使用。&lt;/p&gt;
&lt;h2 id=&#34;掛載一個本機目錄至容器內&#34;&gt;&lt;a href=&#34;#%e6%8e%9b%e8%bc%89%e4%b8%80%e5%80%8b%e6%9c%ac%e6%a9%9f%e7%9b%ae%e9%8c%84%e8%87%b3%e5%ae%b9%e5%99%a8%e5%85%a7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;掛載一個本機目錄至容器內
&lt;/h2&gt;&lt;p&gt;除了將容器內指定的檔案綁定到本機之外，我們也可以將原先就存在於本機的檔案/資料夾&lt;strong&gt;加載&lt;/strong&gt;到容器內部，舉例來說今天寫了一個影像處理相關的程式，我們把它丟到 docker 上面跑，我們可以把想要處理的影像存在本地端，然後加載到容器內，就可以很方便的測試結果是否正確。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker run -d -P &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --name imageProcess &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --mount &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bind,source&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/src/testImage,target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/share/src/testImage &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    imageDocker:latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;把存在本地端的 /src/testImage 資料夾加載到容器內，記得要加參數 &lt;strong&gt;type=bind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 預設掛載目錄的權限是&lt;strong&gt;讀寫&lt;/strong&gt;，如果想用成唯讀，則要另外加上參數 &lt;strong&gt;readonly&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~$ docker run -d -P &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --name imageProcess &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    --mount &lt;span class=&#34;nv&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bind,source&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/src/testImage,target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/share/src/testImage,readonly &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    imageDocker:latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;除了目錄以外也可以掛載單個文件，像是想要紀錄 container 內部的 history，可以綁定/root/.bash_history 等等多種應用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;reference&#34;&gt;&lt;a href=&#34;#reference&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Reference
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://vuepress.mirror.docker-practice.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker 從入門到實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844904182319841294&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker 安裝並且持久化postgresql資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
