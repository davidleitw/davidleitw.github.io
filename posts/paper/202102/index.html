<!DOCTYPE html>
<html>
  <head>
    <title>GFS</title>
    








  



<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/css/bootstrap.min.css"/>
<link rel="stylesheet" href="/css/layouts/main.css"/>
<link rel="stylesheet" href="/css/style.css"/>
<link rel="stylesheet" href="/css/navigators/navbar.css"/>


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png" />


<link rel="stylesheet" href="/css/style.css"/>

    
<meta name="description" content="GFS" />
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css"
/>
<link rel="stylesheet" href="/css/layouts/single.css"/>
<link rel="stylesheet" href="/css/navigators/sidebar.css">


    
    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    











  





  



<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      <img src="/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png">davidlei Blog</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      </ul>
    </div>
  </div>
  
  <img src="/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png" class="d-none" id="main-logo">
  <img src="/images/inverted-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png" class="d-none" id="inverted-logo">
</nav>



      
      
  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li><a class="" href="/posts/introduction/">About me</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/docker/">Docker</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/network/">Network</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/network/controller/">Controller</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/network/sdn/">SDN</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/network/sdn/sdn1/">SDN_01: 什麼是SDN</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/network/sdn/sdn2/">SDN_02: OpenFlow 1.0</a></li>
  


      </ul>
    </li>
  


      </ul>
    </li>
  

  
  
  
  
    
    
  
  
    
    <li>
      <i class="fas fa-minus-circle"></i><a class="active" href="/posts/paper/">Paper</a>
      
      <ul class="active">
        
  
  
  
  
    
    
  
  
    
    <li><a class="active" href="/posts/paper/202102/">The Google File System</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/paper/summary/">閱讀 Paper 心得整理</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/daily/">日常學習紀錄</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/daily/day1/">每日進度彙整</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content">
    <div class="container p-0 read-area">
      
      <div class="hero-area col-sm-12" id="hero-area" style='background-image: url(https://davidleitw.github.io/images/default-hero.jpg);'>
      </div>

      
      <div class="page-content">
        <div class="author-profile ml-auto align-self-lg-center">
          <img class="rounded-circle" src='/images/author/animeYes.png'/>
          <h5 class="author-name">David Lei</h5>
          <p>February 26, 2021</p>
        </div>

        <div class="title">
          <h1>GFS</h1>
        </div>

        <div class="post-content" id="post-content">
          <p>跟著 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT6.824</a> 的課程進度， 在 Lec3 終於拜讀了這篇經典的論文，<strong><code>GFS</code></strong> 是一個分散式的檔案系統，由 Google 開發。 在2003年時 Google 發表了 <a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">The Google File System</a> 這篇論文來分享一些 <strong><code>GFS</code></strong> 開發上的細節， 雖然 Google 沒有開源這個著名的檔案系統， 不過還是可以由 paper 來窺探當初 Google 設計的細節以及整體的架構。</p>
<h2 id="背景">背景</h2>
<p>為了滿足當初 Google 日漸增長的資料處理需求， Google開發了 <strong><code>GFS</code></strong> 這套分散式檔案系統。</p>
<blockquote>
<p>用分散式的原因: 要處理的檔案大小已經遠遠超過單機可以容納的資料量</p>
</blockquote>
<p>跟過往很多分散式系統一樣，<strong><code>GFS</code></strong>  也追求著以下幾點需求:</p>
<ul>
<li><strong>performance</strong> 性能</li>
<li><strong>scalability</strong> 擴展性</li>
<li><strong>reliability</strong> 可靠性</li>
<li><strong>availability</strong> 可用性</li>
</ul>
<p>因為成本以及其他因素的考量之下，Google 並沒有選擇商業用的 server 來製作 <strong><code>GFS</code></strong> 這套系統， 而且採用一般的 <strong>普通主機(inexpensive commidity hardware)</strong> 來作為叢集成員。因為是普通的主機，所以沒有商業用的 server 穩定， 在設計 <strong><code>GFS</code></strong> 的時候必須一併考慮容錯問題來增加穩定性。</p>
<p>在 <strong>Introduction</strong> 中也有先簡單介紹了 <strong><code>GFS</code></strong> 的幾個特色</p>
<ul>
<li><strong>元件失效(component failures)</strong> 被認為是常態</li>
</ul>
<p><strong><code>GFS</code></strong> 中包含著數以百計或者更多的儲存機器，每一台都有可能在任何一個時間點發生不可預期的錯誤，也有些錯誤是無法從中恢復的。 所以 <strong><code>GFS</code></strong> 需要實現<strong>持續的監控，錯誤偵測，容錯跟自動恢復</strong>等功能。</p>
<ul>
<li><strong><code>GFS</code></strong> 中的檔案通常大(GB級以上)而少</li>
</ul>
<p>大的檔案裡面可能含有數億個 object， 一次管理數億個 kb 大小的物件是很不明智的。 所以 I/O 操作，Block 大小等參數都需要另外考慮。</p>
<ul>
<li>資料讀寫特性(絕大部份資料都符合以下特性)</li>
</ul>
<p>對於大部份資料都會將新資料添加在舊文件的尾部而不是去修改它，一旦寫入完成，文件將會變成唯讀，且必定是按照順序讀(only sequentially)。幾乎沒有隨機寫入或者隨機訪問(ex: 在文件中間插入資料等..)。 由此可知 append data 的操作是優化性能以及保持原子性的重點。</p>
<ul>
<li><strong>atomic append operation</strong></li>
</ul>
<p>對於 append 實現了原子操作，使得多個 client 端可以同時對一個文件寫入又不需要額外的同步操作來維持一致性。</p>
<p><strong><code>GFS</code></strong> 沒有強調低延遲，而是把重點放在巨大的 <strong>throughput</strong> 。</p>
<p>在 paper 的 <code>2.1 Assumptions</code> 章節中簡單描述的設計 <strong><code>GFS</code></strong> 的預期目標。</p>
<h2 id="interface">Interface</h2>
<p><strong><code>GFS</code></strong> 提供了一系列類似傳統文件系統的 API 接口，且並沒有完全遵照 POSIX 的規範。</p>
<p>支持一些常見的功能</p>
<ul>
<li><strong>create</strong></li>
<li><strong>delete</strong></li>
<li><strong>open</strong></li>
<li><strong>close</strong></li>
<li><strong>read</strong></li>
<li><strong>write</strong></li>
<li><strong>snapshot</strong></li>
<li><strong>record append</strong></li>
</ul>
<p><strong>snapshot</strong> 指令可以用很低的成本創建一個文件或者目錄的 <code>copy</code>。
<strong>record append</strong> 指令允許多個 <code>clients</code> 同時對一個文件進行寫入動作，同時確保了每個 <code>client</code> 端寫入動作的原子性。讓 <code>client</code> 端可以不用花費額外的心力解決同步問題。</p>
<h2 id="architecture">Architecture</h2>
<p><img src="https://i.imgur.com/ftek3c4.png" alt=""></p>
<p>整個 <strong><code>GFS</code></strong> 包含一個 <code>Master</code> 節點，以及多台 <code>chunk server</code>，每台 <code>chunk server</code> 都可以同時被多個 client 存取。</p>
<p>在 <strong><code>GFS</code></strong> 中儲存的每個文件都會被分割成固定大小的 <code>chunk</code>，每個 <code>chunk</code> 創建時都會由 <code>Master</code> 分配一個 globally unique <code>64 bits chunk handle(chunk ID)</code>。</p>
<p><code>chunk server</code> 會把 <code>chunk</code> 以一般 linux file 的形式儲存在 server 底下的硬碟之中，要讀寫的時候可以根據 <code>chunk handle</code> 以及偏移量來決定範圍。</p>
<blockquote>
<p>預設每個 chunk 都會備份在三個不同的 chuck server，用戶可根據需求調整文件的備份數量。</p>
</blockquote>
<p><code>Master</code> 主要管理所有的 <a href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE">metadata</a>，除了一些系統設定參數之外，還有幾個 table 是需要特別了解的。</p>
<ul>
<li><strong>file name → array of the chunk handle</strong></li>
</ul>
<p><code>Master</code> 管理的資料裡面最重要的一項就是儲存每個文件名稱對應的 <code>chunk handle</code> 陣列，一個資料進入 <strong><code>GFS</code></strong> 當中都會被拆成數個 <code>chunk</code> 分散在系統的各處，當 client 想要存取某個文件時，會先跟 <code>Master</code> 告知文件的名稱，<code>Master</code> 就會查表來得知這個文件的各個 <code>chunk handle</code>。</p>
<ul>
<li><strong>chunk handle 相關資訊</strong></li>
</ul>
<p>獲得 <code>chunk handle</code> 之後，<code>Master</code> 還有另一個表可以查詢各個 <code>chunk handle</code> 的相關資料，</p>
<blockquote>
<p>因為有備份機制，所以每個 chunk 會被儲存在多個 chunk server內。</p>
</blockquote>
<p><code>Master</code> 會以 <strong>HeartBeat message</strong> 的形式週期性得與每個 <code>chunk server</code> 通訊，以獲得 <code>chunk server</code> 的狀態。</p>
<p>metadata會在後面的章節詳細再說明</p>
<h2 id="single-master-設計理念">Single Master 設計理念</h2>
<p>single master 的設計可以讓其透過全局的訊息來紀錄每個 <code>chunk</code> 的位置還有關於資料複製的決策，大大減少了設計的難度。</p>
<p>之後就衍生出另一個問題是只有 single master 的話，設計上需要盡可能的減少 <code>Master</code> 的工作量，不能讓 single master 的設計反而成為整個系統的效能瓶頸。</p>
<p><code>client</code> 的文件讀寫絕對不會透過 <code>Master</code> 來與 <code>chunk server</code> 溝通，<code>Master</code> 的工作只有傳送 <code>chunk</code> 的各種資料，<code>client</code> 獲得應該要與哪一個 <code>chunk server</code> 溝通後，會直接與其連線。</p>
<blockquote>
<p>client 會將 chunk 的 metadata 緩存一段時間，讓後續相同的操作不需要再去詢問 master。</p>
</blockquote>
<h2 id="chunk-size-選擇議題">chunk size 選擇議題</h2>
<p>paper 中有一個章節簡單分析了一下 <code>chunk size</code> 選擇的問題，會甚麼選擇 64MB 這個遠大於普通 block 的大小，以及選擇的優缺點。</p>
<ul>
<li>優點:減少 <code>client</code> 與 <code>master</code> 的通訊量， metadata 大小:</li>
</ul>
<p>由於 <code>sinlge master</code> 的設計，每個環節都要盡可能地降低 <code>master</code> 的運算時間，避免 <code>master</code> 成為整個系統的效能瓶頸。</p>
<p>使用很大的 <code>chunk size</code> 可以讓 <code>client</code> 得到一個 <code>chunk</code> 的位置後進行多次的讀寫(會維持一段時間的 tcp 連線)，不會遇到寫幾行就要換下一個 <code>chunk</code> 的情況發生，另一方面也代表 <code>chunk</code> 的個數會下降，降低 <code>master</code> 需要儲存的 metadata，讓 <code>master</code> 把所有的 metadata 都存放在 memory 內。</p>
<ul>
<li>缺點:熱點(hot spot)問題:</li>
</ul>
<p>對於小文件來說，很可能 <code>chunk</code> 的數量很小，可能只有一個 <code>chunk</code>，這種情況下有可能會發生同時有多個 <code>client</code> 訪問同一個文件的，導致熱點的發生。</p>
<p>這個 file 可能是配置參數 or something else，解決這個方案的長久之計可能是當遇到這種情況的時候允許 <code>client</code> 可以從別的 <code>client</code> 端讀取資料。</p>
<h2 id="metadata">Metadata</h2>
<p><code>Master</code> 主要維護三種類型的 <code>metadata</code></p>
<ul>
<li>命名空間相關</li>
<li>文件名稱(<code>file name</code>)與 <code>chunk</code> 的映射</li>
</ul>
<p>每個文件以 64 MB 的大小分割成數個 <code>chunk</code>，此 table 專門儲存每個文件對應的 <code>chunk</code> 的 <code>chunk handle</code>。</p>
<ul>
<li><code>chunk handle</code> 與 <code>chunk server</code> 的映射</li>
</ul>
<p>因為一個 <code>chunk</code> 會備份之後存在各個 <code>chunk server</code>，所以會有一個 table 特別去紀錄每個 <code>chunk</code> 分別存在哪些 <code>chunk server</code> 內。</p>
<p>所有的 <code>metadata</code> 都會儲存在 <code>master</code> 的 memory 中。除此之外，上述 <code>metadata</code> 的前兩點(namespaces and file-to-chunkmapping) 都會額外的做持久化的處理，定期寫入硬碟內。(paper 中把此檔案稱為 <code>operation log</code>)</p>
<blockquote>
<ul>
<li>持久化是避免 master crush 需要重新啟動的時候可以回到關機前的狀態。</li>
<li><code>master</code> 除了在自己本地的硬碟存檔外，也會在遠端的機器備份 <code>operation log</code> 檔案。</li>
<li><code>master</code> 不會把 <code>chunk</code> 的實際位置寫入 <code>operation log</code> 中，當 <code>master</code> 重新啟動之後會先 ask 每個 <code>chunk server</code> 來建立 <code>chunk</code> 的對應表。</li>
</ul>
</blockquote>
<p>把 <code>metadata</code> 保存在記憶體可以讓 <code>master</code> 很有效率的定期掃描所有的 <code>metadata</code>，藉此來達到 <code>chunk</code> 回收，負載平衡等操作。</p>
<h2 id="263-operation-log">2.6.3 Operation Log</h2>
<p>假設今天系統已經跑了好幾個月甚至一兩年了，突然 <code>master</code> crush，需要按照 <code>operation log</code> 重新 set up 整個系統，如果從一開始的 <code>log</code> 慢慢條列執行，可以預期整個系統重啟的時間會非常的久，這對於一個大型系統來說是不太能接受的。</p>
<p>為了讓重新啟動的時間降低，必須要想辦法讓 <code>log</code> 盡可能的變小，所以在 <code>log</code> 增長一定長度之後 <code>master</code> 就會創建 <code>checkpoint file</code>(並且刪掉舊的 <code>log file</code>)，就像是遊戲的存檔點一樣，可以讓我們死掉之後不用重頭開始玩起。</p>
<p>有了 <code>checkpoint</code> 之後 <code>master</code> 重啟只要讀取最新的一次 <code>checkpoint file</code> 即可，<code>checkpoint file</code> 是以類似 compact B-tree 的資料結構儲存的，讀取這個檔案後可以把整個 data structure 映射到記憶體內不需要額外的處理，大大的加快了整個重啟的時間。</p>
<h2 id="consistency-model-一致性模型">Consistency Model 一致性模型</h2>
<ul>
<li>任何有關於 <code>file namespace</code> 的操作都是 atomic的，例如 <code>create</code> 等等操作，並且經由 <code>master</code> 直接處理。</li>
</ul>
<p>因為 <code>client</code> 可能同時發送指令，<code>master</code> 會依照 <code>operation log</code> 來決定執行順序，這也是 <code>operation log</code> 的另一個重要用處。</p>
<p><code>GFS</code> 中的資料大致上分成三種狀態:</p>
<ul>
<li>客戶端讀取不同 Replica 時可能會讀到不同的內容，將資料定義為 <strong><code>Inconsistent(不一致)</code></strong>。</li>
<li>客戶端無論讀取哪份 Replica 讀到的內容都是相同的，將資料定義為 <strong><code>Consistent(一致)</code></strong>。</li>
<li>客戶端皆能看到上一次修改的全部內容，且該內容是一致的，將資料定義為 <strong><code>Defined(確定的)</code></strong>。</li>
</ul>
<blockquote>
<p>file region 不太好翻譯成中文，可以理解成該次操作所涉及到的文件範圍。
paper 中這個章節都是用 region 代指資料。</p>
</blockquote>
<p>那狀態的改變想當然就會取決於文件的修改類型以及是否成功</p>
<ul>
<li>單一寫入<strong>成功</strong>，且沒有與其他 <code>concurrent </code> 的寫入重疊，將這部份修改的文件定為 <code>Defined</code>(同時也隱含著滿足 <code>Consistent</code>)。</li>
<li>並行寫入<strong>成功</strong>，只能說這部份的修改滿足 <code>Consistent</code> 但 <code>Undefined</code>，因為客戶端無法看出單獨的修改內容。</li>
<li>寫入失敗會被定義成 <code>Inconsistent</code> 而且 <code>Undefined</code>。</li>
</ul>
<blockquote>
<p>所有的規則都被總結在下方的圖表</p>
</blockquote>
<p><img src="https://i.imgur.com/xluSnsz.png" alt=""></p>
<p><code>Data mutations(資料修改)</code> 也分成兩種不同的類型:</p>
<ul>
<li><strong><code>writes</code></strong> → 需要自行決定 <code>offset</code>:</li>
</ul>
<p><code>writes</code> 可以讓 <code>application</code> 由指定的 <code>offset</code> 來決定位置寫入資料。</p>
<ul>
<li><strong><code>record appends</code></strong> → 由 <code>GFS</code> 指定 <code>offset</code>:</li>
</ul>
<p><code>record appends</code> 可以確保動作是 atomic 且 at least once，其操作的 <code>offset</code> 由 <code>GFS</code> 來決定。寫入完成之後 <code>GFS</code> 會把實際寫入的 <code>offset</code> 回傳給客戶端(代表寫入 data 的 region 的起始位置)</p>
<blockquote>
<p><code>GFS</code> 可能會在文件中寫入 <code>padding(填充)</code> 或者重複的資料，就算有也只算佔整個文件的一小部份，這些多餘的資料 region 會被認為是 <code>Inconsistent</code>。
客戶端還是有機會會讀取到重複的資料，這時候只能依靠上層 application 來過濾重複的訊息。</p>
</blockquote>
<p>在執行了一系列的 <code>successful mutation</code> 之後，<code>GFS</code> 保證修改的 <code>file region</code> 是 <code>Defined</code> 的狀態。為此 <code>GFS</code> 有兩個機制可以協助達成此目的。</p>
<ul>
<li>Applying mutations to a chunk in the same order on all its replicas</li>
</ul>
<p>按照上面有提到的，根據 <code>operations log</code> 來控制指令的順序。</p>
<ul>
<li>Using chunk version numbers to detect stale replica that missed mutations</li>
</ul>
<p>使用 <code>chunk version numbers</code> 來偵測是否有哪個 <code>chunk server</code> 中的 <code>chunk</code> 版本不是最新的。如果版本跟其餘不同有可能是該 <code>chunk server</code> 剛剛 crush 導致錯過了中間的一些修改。</p>
<p>被偵測到錯誤的 <code>chunk</code> 之後不會再被 <code>client</code> 的指令調用，當 <code>client</code> 詢問 <code>master</code> 時也不會再回傳該 <code>chunk</code> 的位置。等到下一輪 <code>master</code> 定期掃描時該 <code>chunk</code> 就會被 <code>garbage collected</code> 掉。</p>
<p><code>GFS</code> 內有兩種容錯機制</p>
<ul>
<li><code>master</code> 週期性的 <code>handshakes</code> 來詢問每個 <code>chunk server</code> 確認是否正常運作</li>
<li>如果有 <code>replica</code> 的資料損毀，可以藉由 <code>checksum</code> 的機制檢測出來，然後可以藉由其他的 <code>replica</code> 來恢復資料。</li>
</ul>
<blockquote>
<p>通常 master 偵測到錯誤並且反應的時間大概是幾分鐘之內。</p>
</blockquote>
<h2 id="272-implications-for-applications">2.7.2 Implications for Applications</h2>
<p>大部分的 <code>application</code> 都採取 <strong>appending(寫在尾部)</strong> 的寫入方式， <code>GFS</code> 對於 append 有做性能上的優化。通常一個 <code>writer</code> 只會負責單一文件，不會寫入到一半跑去寫別的文件，當這次的寫入完成時，<code>GFS</code> 會保證原子性的方式把文件改名成一個永久的文件名稱。</p>
<h3 id="checkpoint">checkpoint</h3>
<p>每個 <code>application</code> 都會週期性的維護一個 <code>checkpoint</code> 訊息，該訊息紀錄每次成功寫入後的位置同時也是 <code>Defined</code> 狀態的結束位置，每次 <code>append</code> 的操作都會更新這個訊息，<code>writer</code> 如果遇到什麼突發狀況中止了，下次也可以從 <code>checkpoint</code> 開始繼續寫入，<code>reader</code> 讀取資料也會把 <code>checkpoint</code> 當作結束位置。</p>
<p><code>checkpoint</code> 也會同時紀錄 <code>checksums</code> 來確保每個段落的正確性。<code>checkpoint</code> 的設計可以使得 <code>writer</code> 一段一段的寫入資料，讓 <code>reader</code> 可以從還沒有寫入完成的文件中讀取資料。</p>
<h3 id="concurrently-append">concurrently append</h3>
<p>在另外一個常見的使用場景，通常會有很多 <code>writer</code> 同時對同一個檔案做修改，通常是在合併結果或者是用於 <code>生產者–消費者模型</code>。<code>Record append</code> 的 <code>append-at-least-once</code> 特性保證了每個 <code>writer</code> 的輸出。</p>
<p>在前面的<a href="#Consistency-Model-%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B">說明</a>中有簡單提到過 <code>GFS</code> 可能會在文件中寫入 <code>padding(填充)</code> 或者<code>duplicates(重複的資料)</code>。<code>checkpoint</code> 也可以讓 <code>reader</code> 有效的處理上述的問題，盡可能得去避免讀到錯誤的資料。<code>writer</code> 在每次 <code>checkpoint</code> 的時候都會加入 <code>checksum</code> 來驗證上面段落的有效性，<code>reader</code> 可以藉由 <code>checksum</code> 來辨識 <code>padding</code> 或者 <code>duplicates</code>。</p>
<p>在 paper 中也有簡單說明如果 <code>application</code> 某些應用場景無法忍受偶發的重複資料，可以在 <code>checkpoint</code> 的地方加入一個 <code>unique identifiers</code>，讀入資料的時候可以藉由 ID 來避免重複資料。</p>
<h2 id="system-interactions">System interactions</h2>
<h3 id="lease租約">Lease(租約)</h3>
<p>因為我們每份 <code>chunk</code> 都會備份在不同的 <code>chunk server</code> 內，所以需要有一個機制在修改完 <code>chunk</code> 之後讓所有複製的 <code>chunk</code> 都相同的內容。<code>GFS</code> 中使用 <code>leases</code> 去處理多個 <code>chunk</code> 在經過修改之後的一致性問題。</p>
<h2 id="reference">reference</h2>
<ul>
<li><a href="https://www.itread01.com/content/1546962067.html">Google File System及其繼任者Colossus
</a></li>
<li><a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">The Google File System</a></li>
<li><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT6.824</a></li>
<li><a href="https://www.open-open.com/lib/view/open1328763454608.html">GFS 中文參考</a></li>
</ul>

        </div>

        
        

        
      <hr />
        <div class="row next-prev-navigator">


  

  

  

  

  
    
    
      
        
        
        <div class="col-md-12 next-article">
          <a href="/posts/paper/summary/" class="btn btn-outline-info">
            <span>Next <i class="fas fa-chevron-circle-right"></i></span>
            <br />
            <span>Papers</span>
          </a>
        </div>
      
    
  

  

</div>

      <hr />
      
      
      </div>
    </div>
  </div>
  
</section>


      
      
  <section class="toc-section" id="toc-section">
    
  </section>

    </div>

    

  




  




  
  
    
  









  







<footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#about">About</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#experiences">Experiences</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#projects">Projects</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
              </li>
            
        </ul>
        

      </div>
      
      <div class="col-md-4 col-sm-12">
        <h5>Contact me:</h5>
        <ul>
          
          <li><span>Email: </span> <span>davidleitw@gmail.com</span></li>
          
        </ul>
      </div>
      
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">©2021 create by DAVID LEI</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by
        <img
          src="/images/hugo-logo.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/js/jquery-3.4.1.min.js"></script>
<script src="/js/popper.min.js"></script>
<script src="/js/bootstrap.min.js"></script>

<script src="/js/navbar.js"></script>
<script src="/js/main.js"></script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
<script src="/js/single.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);">
</script>



  </body>
</html>
