<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Paper on davidLei</title>
        <link>http://localhost:44973/tags/paper/</link>
        <description>Recent content in Paper on davidLei</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <copyright>davidlei</copyright>
        <lastBuildDate>Mon, 19 Dec 2022 22:13:53 +0800</lastBuildDate><atom:link href="http://localhost:44973/tags/paper/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Bypassing the Load Balancer Without Regrets - SoCC ’20</title>
        <link>http://localhost:44973/p/bypassing-the-load-balancer-without-regrets-socc-20/</link>
        <pubDate>Mon, 19 Dec 2022 22:13:53 +0800</pubDate>
        
        <guid>http://localhost:44973/p/bypassing-the-load-balancer-without-regrets-socc-20/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;前言
&lt;/h2&gt;&lt;p&gt;最近為了找論文題目看了不少論文，剛好趁這個機會寫點文章當作讀這些 paper 的學習筆記，&lt;a class=&#34;link&#34; href=&#34;https://marioskogias.github.io/docs/crab.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;這篇&lt;/a&gt; 主要提出一個新的 Load balance 的機制，希望可以消除 LB 在 data path 花費的時間，讓 LB 專注於處理連線請求，決定 connection 去往哪台 server 之後就讓 Client 與 server 之間直接連線，細節就看底下的簡介或者論文內文吧，我覺得這篇 paper 在概念講解的地方畫了幾張不錯的示意圖，如果想要解釋 L4 的 load balancer 怎麼運作的，這是一篇滿推薦的論文。&lt;/p&gt;
&lt;p&gt;這篇論文的作者也用了 P4, eBPF 等技術實現了他們的論文，如果有興趣的也可以研究看看實現的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/epfl-dcsl/crab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;常見-lb-技術分類&#34;&gt;&lt;a href=&#34;#%e5%b8%b8%e8%a6%8b-lb-%e6%8a%80%e8%a1%93%e5%88%86%e9%a1%9e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;常見 LB 技術分類
&lt;/h2&gt;&lt;p&gt;這篇論文在前面的幾個段落介紹了常見了 Load Belance 技術，然後規劃了一些簡單的實驗來分析各種不同技術的優劣，文中用以下五個標準/指標來分類不同種類的 LB 技術，如下圖所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/STj3dNc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;比較圖表如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Vyopids.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中 L4 的 Load Balancer 以形式可以分成有沒有支援 DSR(Direct Server Return)，又或者分為 Stateless 和 Stateful，以筆者的理解大規模的服務來說會盡量把 Load Balancer 設計成無狀態的，這樣才能把雲端環境的&lt;strong&gt;動態&lt;/strong&gt;優勢發揮出來，像是另一篇關於 LB 的論文 &lt;a class=&#34;link&#34; href=&#34;https://www.usenix.org/system/files/nsdi20-paper-barbette.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;A High-Speed Load-Balancer Design with Guaranteed Per-Connection-Consistency NSDI2020&lt;/a&gt; 有提到一個觀點，為什麼現在主流的 LB 技術都不依靠像是 weighted round robin 或者 power of two choices 這種可以根據伺服器狀態來最佳化負載的演算法，以下引用該文章的說法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A natural question to ask is why existing load balancers do not rely on more sophisticated load balancing mechanisms, e.g., weighted round robin [51],“power of two choices” [33], or least loaded server. The answer lies in the extreme dynamicity of cloud environments. Services and load balancers “must be designed to gracefully withstand traffic surges of hundreds of times their usual loads, as well as DDoS attacks” [3]. This means that the number of servers and load balancers used to provide a service can quickly change over time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單來說，負載平衡技術在雲端環境下會面臨的挑戰在於 LB 或者後端 Server 的數量會根據請求的流量動態調整，或者是以容器為單位的調度，這種時候像是 WRR, P2C 這類的演算法就毫無用武之地，因為 Server 的數目跟狀態隨時都在變更，無法根據當時的狀態找出較好的調度方案。&lt;/p&gt;
&lt;p&gt;實驗部份就不過多敘述了，接著來看這篇論文提出的 LB 方案想要滿足什麼條件，用什麼方式達成&lt;/p&gt;
&lt;h2 id=&#34;crab-design&#34;&gt;&lt;a href=&#34;#crab-design&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;CRAB design
&lt;/h2&gt;&lt;p&gt;這篇論文提出的新 LB 技術取名為 &lt;strong&gt;C&lt;/strong&gt;onnection &lt;strong&gt;R&lt;/strong&gt;edirect Lo&lt;strong&gt;A&lt;/strong&gt;d &lt;strong&gt;B&lt;/strong&gt;alancer(&lt;strong&gt;CRAB&lt;/strong&gt;)，作者用這段話總結實作的理念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Implementing a centralized, stateful load balancing policy at a connection granularity requires the load balancer’s involvement only during connection setup, following which the client and server can communicate directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;支援-dsr-模式的-lb-運作流程&#34;&gt;&lt;a href=&#34;#%e6%94%af%e6%8f%b4-dsr-%e6%a8%a1%e5%bc%8f%e7%9a%84-lb-%e9%81%8b%e4%bd%9c%e6%b5%81%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;支援 DSR 模式的 LB 運作流程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/imKOVJL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在這個握手過程中，Client 會先向 Load Balancer 的 VIP 發送 TCP SYN 封包。Load Balancer 會將這個連接分配給特定的後端伺服器，並將 SYN 封包轉發到其 DIP。由於啟用了 DSR，伺服器會直接對 Client 發送一個源 IP 為 VIP 的 SYN-ACK 封包。最後，Client 會向 Load Balancer 發送 ACK 封包，Load Balancer 會將其轉發到後端伺服器，以完成連接建立。&lt;/p&gt;
&lt;p&gt;為了能把 LB 從 data path 抽離，CRAB 運用了一個 &lt;em&gt;Connection Redirection&lt;/em&gt; (&lt;strong&gt;CR&lt;/strong&gt;) 的技術。&lt;/p&gt;
&lt;p&gt;通常，當 Client 發送 SYN 包時，它會等待目標 IP 的 SYN-ACK 響應。如果收到的 SYN-ACK 與之前發送 SYN 的地址不同，則客戶端會丟棄該包。CR 的目的是允許 Client 在一定條件下接受與發送 SYN 地址不同的 SYN-ACK 包。這使得 Client 可以通過驗證收到的 SYN-ACK 包是其發起的握手的一部分來避免與負載平衡器直接連接，而是將連接重定向到另一個目標，CR 作為一個 TCP 的擴充 option 被實現，用 4 bytes 來存放初始丟 SYN 封包的 Initial destination IP。&lt;/p&gt;
&lt;p&gt;運用了 CR 之後建立連線的示意圖如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nSgxPCe.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在傳統的 TCP 情況下，Client 首先向 Load Balancer 發送 TCP SYN 包。這個 TCP SYN 包也會指示 Client 是否支持 CR。在這種情況下，我們假設 Client 支持 CR。&lt;/li&gt;
&lt;li&gt;Load Balancer 將該連接分配給特定的後端服務器，並將 SYN 包轉發到其 DIP。此外，它使用 Connection Redirect 選項將其 VIP 包含在數據包中，並告知後端服務器這是一個重定向連接。&lt;/li&gt;
&lt;li&gt;服務器隨後直接將 SYN-ACK 包發送到 Client，源 IP 設置為其自己，並使用 Connection Redirect 選項回顯 Load Balancer 的 VIP。&lt;/li&gt;
&lt;li&gt;最後， Client 處理新的 TCP 選項，並將連接重定向，從而將 ACK 包直接發送到後端服務器並繞過 Load Balancer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qspk11h.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;&lt;a href=&#34;#%e7%b5%90%e8%ab%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;結論
&lt;/h2&gt;&lt;p&gt;這套解決方案的確直觀的降低了 Load Balancer 的壓力，LB 只要專心處理建立連線的 SYN 封包，也能夠搭配自己的負載平衡策略，但缺點可能是如果要妥善利用這個機制需要 Client 也支援 CR，否則不支援的情況會退回原先的 stateless 的 load balance 機制。&lt;/p&gt;
&lt;p&gt;最後筆者比較在意的地方是把 DIP 暴露給 Client 有一定的風險，我認為這種架構比較適合內部的 LB，論文第一段也有提到適合場景是 Internel load balancer。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>The Google File System (GFS) 論文心得</title>
        <link>http://localhost:44973/p/the-google-file-system-gfs-%E8%AB%96%E6%96%87%E5%BF%83%E5%BE%97/</link>
        <pubDate>Fri, 13 Aug 2021 21:34:43 +0800</pubDate>
        
        <guid>http://localhost:44973/p/the-google-file-system-gfs-%E8%AB%96%E6%96%87%E5%BF%83%E5%BE%97/</guid>
        <description>&lt;p&gt;跟著 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/schedule.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MIT6.824&lt;/a&gt; 的課程進度， 在 Lec3 終於拜讀了這篇經典的論文，&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 是一個分散式的檔案系統，由 Google 開發。 在2003年時 Google 發表了 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/papers/gfs.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The Google File System&lt;/a&gt; 這篇論文來分享一些 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 開發上的細節， 雖然 Google 沒有開源這個著名的檔案系統， 不過還是可以由 paper 來窺探當初 Google 設計的細節以及整體的架構。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;&lt;a href=&#34;#%e8%83%8c%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;背景
&lt;/h2&gt;&lt;p&gt;為了滿足當初 Google 日漸增長的資料處理需求， Google開發了 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 這套分散式檔案系統。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用分散式的原因: 要處理的檔案大小已經遠遠超過單機可以容納的資料量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟過往很多分散式系統一樣，&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt;  也追求著以下幾點需求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;performance&lt;/strong&gt; 性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scalability&lt;/strong&gt; 擴展性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reliability&lt;/strong&gt; 可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;availability&lt;/strong&gt; 可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為成本以及其他因素的考量之下，Google 並沒有選擇商業用的 server 來製作 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 這套系統， 而且採用一般的 &lt;strong&gt;普通主機(inexpensive commidity hardware)&lt;/strong&gt; 來作為叢集成員。因為是普通的主機，所以沒有商業用的 server 穩定， 在設計 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 的時候必須一併考慮容錯問題來增加穩定性。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Introduction&lt;/strong&gt; 中也有先簡單介紹了 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 的幾個特色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;元件失效(component failures)&lt;/strong&gt; 被認為是常態&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 中包含著數以百計或者更多的儲存機器，每一台都有可能在任何一個時間點發生不可預期的錯誤，也有些錯誤是無法從中恢復的。 所以 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 需要實現&lt;strong&gt;持續的監控，錯誤偵測，容錯跟自動恢復&lt;/strong&gt;等功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 中的檔案通常大(GB級以上)而少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的檔案裡面可能含有數億個 object， 一次管理數億個 kb 大小的物件是很不明智的。 所以 I/O 操作，Block 大小等參數都需要另外考慮。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料讀寫特性(絕大部份資料都符合以下特性)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對於大部份資料都會將新資料添加在舊文件的尾部而不是去修改它，一旦寫入完成，文件將會變成唯讀，且必定是按照順序讀(only sequentially)。幾乎沒有隨機寫入或者隨機訪問(ex: 在文件中間插入資料等..)。 由此可知 append data 的操作是優化性能以及保持原子性的重點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;atomic append operation&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對於 append 實現了原子操作，使得多個 client 端可以同時對一個文件寫入又不需要額外的同步操作來維持一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 沒有強調低延遲，而是把重點放在巨大的 &lt;strong&gt;throughput&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;在 paper 的 &lt;code&gt;2.1 Assumptions&lt;/code&gt; 章節中簡單描述的設計 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 的預期目標。&lt;/p&gt;
&lt;h2 id=&#34;interface&#34;&gt;&lt;a href=&#34;#interface&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Interface
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 提供了一系列類似傳統文件系統的 API 接口，且並沒有完全遵照 POSIX 的規範。&lt;/p&gt;
&lt;p&gt;支持一些常見的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;create&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;delete&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;open&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;close&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;write&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;snapshot&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;record append&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;snapshot&lt;/strong&gt; 指令可以用很低的成本創建一個文件或者目錄的 &lt;code&gt;copy&lt;/code&gt;。
&lt;strong&gt;record append&lt;/strong&gt; 指令允許多個 &lt;code&gt;clients&lt;/code&gt; 同時對一個文件進行寫入動作，同時確保了每個 &lt;code&gt;client&lt;/code&gt; 端寫入動作的原子性。讓 &lt;code&gt;client&lt;/code&gt; 端可以不用花費額外的心力解決同步問題。&lt;/p&gt;
&lt;h2 id=&#34;architecture&#34;&gt;&lt;a href=&#34;#architecture&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Architecture
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ftek3c4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;整個 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 包含一個 &lt;code&gt;Master&lt;/code&gt; 節點，以及多台 &lt;code&gt;chunk server&lt;/code&gt;，每台 &lt;code&gt;chunk server&lt;/code&gt; 都可以同時被多個 client 存取。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 中儲存的每個文件都會被分割成固定大小的 &lt;code&gt;chunk&lt;/code&gt;，每個 &lt;code&gt;chunk&lt;/code&gt; 創建時都會由 &lt;code&gt;Master&lt;/code&gt; 分配一個 globally unique &lt;code&gt;64 bits chunk handle(chunk ID)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chunk server&lt;/code&gt; 會把 &lt;code&gt;chunk&lt;/code&gt; 以一般 linux file 的形式儲存在 server 底下的硬碟之中，要讀寫的時候可以根據 &lt;code&gt;chunk handle&lt;/code&gt; 以及偏移量來決定範圍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;預設每個 chunk 都會備份在三個不同的 chuck server，用戶可根據需求調整文件的備份數量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Master&lt;/code&gt; 主要管理所有的 &lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;metadata&lt;/a&gt;，除了一些系統設定參數之外，還有幾個 table 是需要特別了解的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;file name → array of the chunk handle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Master&lt;/code&gt; 管理的資料裡面最重要的一項就是儲存每個文件名稱對應的 &lt;code&gt;chunk handle&lt;/code&gt; 陣列，一個資料進入 &lt;strong&gt;&lt;code&gt;GFS&lt;/code&gt;&lt;/strong&gt; 當中都會被拆成數個 &lt;code&gt;chunk&lt;/code&gt; 分散在系統的各處，當 client 想要存取某個文件時，會先跟 &lt;code&gt;Master&lt;/code&gt; 告知文件的名稱，&lt;code&gt;Master&lt;/code&gt; 就會查表來得知這個文件的各個 &lt;code&gt;chunk handle&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;chunk handle 相關資訊&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;獲得 &lt;code&gt;chunk handle&lt;/code&gt; 之後，&lt;code&gt;Master&lt;/code&gt; 還有另一個表可以查詢各個 &lt;code&gt;chunk handle&lt;/code&gt; 的相關資料，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因為有備份機制，所以每個 chunk 會被儲存在多個 chunk server內。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Master&lt;/code&gt; 會以 &lt;strong&gt;HeartBeat message&lt;/strong&gt; 的形式週期性得與每個 &lt;code&gt;chunk server&lt;/code&gt; 通訊，以獲得 &lt;code&gt;chunk server&lt;/code&gt; 的狀態。&lt;/p&gt;
&lt;p&gt;metadata會在後面的章節詳細再說明&lt;/p&gt;
&lt;h2 id=&#34;single-master-設計理念&#34;&gt;&lt;a href=&#34;#single-master-%e8%a8%ad%e8%a8%88%e7%90%86%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Single Master 設計理念
&lt;/h2&gt;&lt;p&gt;single master 的設計可以讓其透過全局的訊息來紀錄每個 &lt;code&gt;chunk&lt;/code&gt; 的位置還有關於資料複製的決策，大大減少了設計的難度。&lt;/p&gt;
&lt;p&gt;之後就衍生出另一個問題是只有 single master 的話，設計上需要盡可能的減少 &lt;code&gt;Master&lt;/code&gt; 的工作量，不能讓 single master 的設計反而成為整個系統的效能瓶頸。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client&lt;/code&gt; 的文件讀寫絕對不會透過 &lt;code&gt;Master&lt;/code&gt; 來與 &lt;code&gt;chunk server&lt;/code&gt; 溝通，&lt;code&gt;Master&lt;/code&gt; 的工作只有傳送 &lt;code&gt;chunk&lt;/code&gt; 的各種資料，&lt;code&gt;client&lt;/code&gt; 獲得應該要與哪一個 &lt;code&gt;chunk server&lt;/code&gt; 溝通後，會直接與其連線。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;client 會將 chunk 的 metadata 緩存一段時間，讓後續相同的操作不需要再去詢問 master。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;chunk-size-選擇議題&#34;&gt;&lt;a href=&#34;#chunk-size-%e9%81%b8%e6%93%87%e8%ad%b0%e9%a1%8c&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;chunk size 選擇議題
&lt;/h2&gt;&lt;p&gt;paper 中有一個章節簡單分析了一下 &lt;code&gt;chunk size&lt;/code&gt; 選擇的問題，會甚麼選擇 64MB 這個遠大於普通 block 的大小，以及選擇的優缺點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;優點:減少 &lt;code&gt;client&lt;/code&gt; 與 &lt;code&gt;master&lt;/code&gt; 的通訊量， metadata 大小:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於 &lt;code&gt;sinlge master&lt;/code&gt; 的設計，每個環節都要盡可能地降低 &lt;code&gt;master&lt;/code&gt; 的運算時間，避免 &lt;code&gt;master&lt;/code&gt; 成為整個系統的效能瓶頸。&lt;/p&gt;
&lt;p&gt;使用很大的 &lt;code&gt;chunk size&lt;/code&gt; 可以讓 &lt;code&gt;client&lt;/code&gt; 得到一個 &lt;code&gt;chunk&lt;/code&gt; 的位置後進行多次的讀寫(會維持一段時間的 tcp 連線)，不會遇到寫幾行就要換下一個 &lt;code&gt;chunk&lt;/code&gt; 的情況發生，另一方面也代表 &lt;code&gt;chunk&lt;/code&gt; 的個數會下降，降低 &lt;code&gt;master&lt;/code&gt; 需要儲存的 metadata，讓 &lt;code&gt;master&lt;/code&gt; 把所有的 metadata 都存放在 memory 內。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺點:熱點(hot spot)問題:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對於小文件來說，很可能 &lt;code&gt;chunk&lt;/code&gt; 的數量很小，可能只有一個 &lt;code&gt;chunk&lt;/code&gt;，這種情況下有可能會發生同時有多個 &lt;code&gt;client&lt;/code&gt; 訪問同一個文件的，導致熱點的發生。&lt;/p&gt;
&lt;p&gt;這個 file 可能是配置參數 or something else，解決這個方案的長久之計可能是當遇到這種情況的時候允許 &lt;code&gt;client&lt;/code&gt; 可以從別的 &lt;code&gt;client&lt;/code&gt; 端讀取資料。&lt;/p&gt;
&lt;h2 id=&#34;metadata&#34;&gt;&lt;a href=&#34;#metadata&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Metadata
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Master&lt;/code&gt; 主要維護三種類型的 &lt;code&gt;metadata&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名空間相關&lt;/li&gt;
&lt;li&gt;文件名稱(&lt;code&gt;file name&lt;/code&gt;)與 &lt;code&gt;chunk&lt;/code&gt; 的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每個文件以 64 MB 的大小分割成數個 &lt;code&gt;chunk&lt;/code&gt;，此 table 專門儲存每個文件對應的 &lt;code&gt;chunk&lt;/code&gt; 的 &lt;code&gt;chunk handle&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chunk handle&lt;/code&gt; 與 &lt;code&gt;chunk server&lt;/code&gt; 的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為一個 &lt;code&gt;chunk&lt;/code&gt; 會備份之後存在各個 &lt;code&gt;chunk server&lt;/code&gt;，所以會有一個 table 特別去紀錄每個 &lt;code&gt;chunk&lt;/code&gt; 分別存在哪些 &lt;code&gt;chunk server&lt;/code&gt; 內。&lt;/p&gt;
&lt;p&gt;所有的 &lt;code&gt;metadata&lt;/code&gt; 都會儲存在 &lt;code&gt;master&lt;/code&gt; 的 memory 中。除此之外，上述 &lt;code&gt;metadata&lt;/code&gt; 的前兩點(namespaces and file-to-chunkmapping) 都會額外的做持久化的處理，定期寫入硬碟內。(paper 中把此檔案稱為 &lt;code&gt;operation log&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;持久化是避免 master crush 需要重新啟動的時候可以回到關機前的狀態。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt; 除了在自己本地的硬碟存檔外，也會在遠端的機器備份 &lt;code&gt;operation log&lt;/code&gt; 檔案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt; 不會把 &lt;code&gt;chunk&lt;/code&gt; 的實際位置寫入 &lt;code&gt;operation log&lt;/code&gt; 中，當 &lt;code&gt;master&lt;/code&gt; 重新啟動之後會先 ask 每個 &lt;code&gt;chunk server&lt;/code&gt; 來建立 &lt;code&gt;chunk&lt;/code&gt; 的對應表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;把 &lt;code&gt;metadata&lt;/code&gt; 保存在記憶體可以讓 &lt;code&gt;master&lt;/code&gt; 很有效率的定期掃描所有的 &lt;code&gt;metadata&lt;/code&gt;，藉此來達到 &lt;code&gt;chunk&lt;/code&gt; 回收，負載平衡等操作。&lt;/p&gt;
&lt;h2 id=&#34;263-operation-log&#34;&gt;&lt;a href=&#34;#263-operation-log&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;2.6.3 Operation Log
&lt;/h2&gt;&lt;p&gt;假設今天系統已經跑了好幾個月甚至一兩年了，突然 &lt;code&gt;master&lt;/code&gt; crush，需要按照 &lt;code&gt;operation log&lt;/code&gt; 重新 set up 整個系統，如果從一開始的 &lt;code&gt;log&lt;/code&gt; 慢慢條列執行，可以預期整個系統重啟的時間會非常的久，這對於一個大型系統來說是不太能接受的。&lt;/p&gt;
&lt;p&gt;為了讓重新啟動的時間降低，必須要想辦法讓 &lt;code&gt;log&lt;/code&gt; 盡可能的變小，所以在 &lt;code&gt;log&lt;/code&gt; 增長一定長度之後 &lt;code&gt;master&lt;/code&gt; 就會創建 &lt;code&gt;checkpoint file&lt;/code&gt;(並且刪掉舊的 &lt;code&gt;log file&lt;/code&gt;)，就像是遊戲的存檔點一樣，可以讓我們死掉之後不用重頭開始玩起。&lt;/p&gt;
&lt;p&gt;有了 &lt;code&gt;checkpoint&lt;/code&gt; 之後 &lt;code&gt;master&lt;/code&gt; 重啟只要讀取最新的一次 &lt;code&gt;checkpoint file&lt;/code&gt; 即可，&lt;code&gt;checkpoint file&lt;/code&gt; 是以類似 compact B-tree 的資料結構儲存的，讀取這個檔案後可以把整個 data structure 映射到記憶體內不需要額外的處理，大大的加快了整個重啟的時間。&lt;/p&gt;
&lt;h2 id=&#34;consistency-model-一致性模型&#34;&gt;&lt;a href=&#34;#consistency-model-%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Consistency Model 一致性模型
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;任何有關於 &lt;code&gt;file namespace&lt;/code&gt; 的操作都是 atomic的，例如 &lt;code&gt;create&lt;/code&gt; 等等操作，並且經由 &lt;code&gt;master&lt;/code&gt; 直接處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為 &lt;code&gt;client&lt;/code&gt; 可能同時發送指令，&lt;code&gt;master&lt;/code&gt; 會依照 &lt;code&gt;operation log&lt;/code&gt; 來決定執行順序，這也是 &lt;code&gt;operation log&lt;/code&gt; 的另一個重要用處。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GFS&lt;/code&gt; 中的資料大致上分成三種狀態:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客戶端讀取不同 Replica 時可能會讀到不同的內容，將資料定義為 &lt;strong&gt;&lt;code&gt;Inconsistent(不一致)&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;客戶端無論讀取哪份 Replica 讀到的內容都是相同的，將資料定義為 &lt;strong&gt;&lt;code&gt;Consistent(一致)&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;客戶端皆能看到上一次修改的全部內容，且該內容是一致的，將資料定義為 &lt;strong&gt;&lt;code&gt;Defined(確定的)&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;file region 不太好翻譯成中文，可以理解成該次操作所涉及到的文件範圍。
paper 中這個章節都是用 region 代指資料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那狀態的改變想當然就會取決於文件的修改類型以及是否成功&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;單一寫入&lt;strong&gt;成功&lt;/strong&gt;，且沒有與其他 &lt;code&gt;concurrent &lt;/code&gt; 的寫入重疊，將這部份修改的文件定為 &lt;code&gt;Defined&lt;/code&gt;(同時也隱含著滿足 &lt;code&gt;Consistent&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;並行寫入&lt;strong&gt;成功&lt;/strong&gt;，只能說這部份的修改滿足 &lt;code&gt;Consistent&lt;/code&gt; 但 &lt;code&gt;Undefined&lt;/code&gt;，因為客戶端無法看出單獨的修改內容。&lt;/li&gt;
&lt;li&gt;寫入失敗會被定義成 &lt;code&gt;Inconsistent&lt;/code&gt; 而且 &lt;code&gt;Undefined&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的規則都被總結在下方的圖表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/xluSnsz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data mutations(資料修改)&lt;/code&gt; 也分成兩種不同的類型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;writes&lt;/code&gt;&lt;/strong&gt; → 需要自行決定 &lt;code&gt;offset&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;writes&lt;/code&gt; 可以讓 &lt;code&gt;application&lt;/code&gt; 由指定的 &lt;code&gt;offset&lt;/code&gt; 來決定位置寫入資料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;record appends&lt;/code&gt;&lt;/strong&gt; → 由 &lt;code&gt;GFS&lt;/code&gt; 指定 &lt;code&gt;offset&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;record appends&lt;/code&gt; 可以確保動作是 atomic 且 at least once，其操作的 &lt;code&gt;offset&lt;/code&gt; 由 &lt;code&gt;GFS&lt;/code&gt; 來決定。寫入完成之後 &lt;code&gt;GFS&lt;/code&gt; 會把實際寫入的 &lt;code&gt;offset&lt;/code&gt; 回傳給客戶端(代表寫入 data 的 region 的起始位置)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;GFS&lt;/code&gt; 可能會在文件中寫入 &lt;code&gt;padding(填充)&lt;/code&gt; 或者重複的資料，就算有也只算佔整個文件的一小部份，這些多餘的資料 region 會被認為是 &lt;code&gt;Inconsistent&lt;/code&gt;。
客戶端還是有機會會讀取到重複的資料，這時候只能依靠上層 application 來過濾重複的訊息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在執行了一系列的 &lt;code&gt;successful mutation&lt;/code&gt; 之後，&lt;code&gt;GFS&lt;/code&gt; 保證修改的 &lt;code&gt;file region&lt;/code&gt; 是 &lt;code&gt;Defined&lt;/code&gt; 的狀態。為此 &lt;code&gt;GFS&lt;/code&gt; 有兩個機制可以協助達成此目的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Applying mutations to a chunk in the same order on all its replicas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照上面有提到的，根據 &lt;code&gt;operations log&lt;/code&gt; 來控制指令的順序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using chunk version numbers to detect stale replica that missed mutations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;chunk version numbers&lt;/code&gt; 來偵測是否有哪個 &lt;code&gt;chunk server&lt;/code&gt; 中的 &lt;code&gt;chunk&lt;/code&gt; 版本不是最新的。如果版本跟其餘不同有可能是該 &lt;code&gt;chunk server&lt;/code&gt; 剛剛 crush 導致錯過了中間的一些修改。&lt;/p&gt;
&lt;p&gt;被偵測到錯誤的 &lt;code&gt;chunk&lt;/code&gt; 之後不會再被 &lt;code&gt;client&lt;/code&gt; 的指令調用，當 &lt;code&gt;client&lt;/code&gt; 詢問 &lt;code&gt;master&lt;/code&gt; 時也不會再回傳該 &lt;code&gt;chunk&lt;/code&gt; 的位置。等到下一輪 &lt;code&gt;master&lt;/code&gt; 定期掃描時該 &lt;code&gt;chunk&lt;/code&gt; 就會被 &lt;code&gt;garbage collected&lt;/code&gt; 掉。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GFS&lt;/code&gt; 內有兩種容錯機制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt; 週期性的 &lt;code&gt;handshakes&lt;/code&gt; 來詢問每個 &lt;code&gt;chunk server&lt;/code&gt; 確認是否正常運作&lt;/li&gt;
&lt;li&gt;如果有 &lt;code&gt;replica&lt;/code&gt; 的資料損毀，可以藉由 &lt;code&gt;checksum&lt;/code&gt; 的機制檢測出來，然後可以藉由其他的 &lt;code&gt;replica&lt;/code&gt; 來恢復資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通常 master 偵測到錯誤並且反應的時間大概是幾分鐘之內。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;272-implications-for-applications&#34;&gt;&lt;a href=&#34;#272-implications-for-applications&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;2.7.2 Implications for Applications
&lt;/h2&gt;&lt;p&gt;大部分的 &lt;code&gt;application&lt;/code&gt; 都採取 &lt;strong&gt;appending(寫在尾部)&lt;/strong&gt; 的寫入方式， &lt;code&gt;GFS&lt;/code&gt; 對於 append 有做性能上的優化。通常一個 &lt;code&gt;writer&lt;/code&gt; 只會負責單一文件，不會寫入到一半跑去寫別的文件，當這次的寫入完成時，&lt;code&gt;GFS&lt;/code&gt; 會保證原子性的方式把文件改名成一個永久的文件名稱。&lt;/p&gt;
&lt;h3 id=&#34;checkpoint&#34;&gt;&lt;a href=&#34;#checkpoint&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;checkpoint
&lt;/h3&gt;&lt;p&gt;每個 &lt;code&gt;application&lt;/code&gt; 都會週期性的維護一個 &lt;code&gt;checkpoint&lt;/code&gt; 訊息，該訊息紀錄每次成功寫入後的位置同時也是 &lt;code&gt;Defined&lt;/code&gt; 狀態的結束位置，每次 &lt;code&gt;append&lt;/code&gt; 的操作都會更新這個訊息，&lt;code&gt;writer&lt;/code&gt; 如果遇到什麼突發狀況中止了，下次也可以從 &lt;code&gt;checkpoint&lt;/code&gt; 開始繼續寫入，&lt;code&gt;reader&lt;/code&gt; 讀取資料也會把 &lt;code&gt;checkpoint&lt;/code&gt; 當作結束位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;checkpoint&lt;/code&gt; 也會同時紀錄 &lt;code&gt;checksums&lt;/code&gt; 來確保每個段落的正確性。&lt;code&gt;checkpoint&lt;/code&gt; 的設計可以使得 &lt;code&gt;writer&lt;/code&gt; 一段一段的寫入資料，讓 &lt;code&gt;reader&lt;/code&gt; 可以從還沒有寫入完成的文件中讀取資料。&lt;/p&gt;
&lt;h3 id=&#34;concurrently-append&#34;&gt;&lt;a href=&#34;#concurrently-append&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;concurrently append
&lt;/h3&gt;&lt;p&gt;在另外一個常見的使用場景，通常會有很多 &lt;code&gt;writer&lt;/code&gt; 同時對同一個檔案做修改，通常是在合併結果或者是用於 &lt;code&gt;生產者–消費者模型&lt;/code&gt;。&lt;code&gt;Record append&lt;/code&gt; 的 &lt;code&gt;append-at-least-once&lt;/code&gt; 特性保證了每個 &lt;code&gt;writer&lt;/code&gt; 的輸出。&lt;/p&gt;
&lt;p&gt;在前面的&lt;a class=&#34;link&#34; href=&#34;#Consistency-Model-%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b&#34; &gt;說明&lt;/a&gt;中有簡單提到過 &lt;code&gt;GFS&lt;/code&gt; 可能會在文件中寫入 &lt;code&gt;padding(填充)&lt;/code&gt; 或者&lt;code&gt;duplicates(重複的資料)&lt;/code&gt;。&lt;code&gt;checkpoint&lt;/code&gt; 也可以讓 &lt;code&gt;reader&lt;/code&gt; 有效的處理上述的問題，盡可能得去避免讀到錯誤的資料。&lt;code&gt;writer&lt;/code&gt; 在每次 &lt;code&gt;checkpoint&lt;/code&gt; 的時候都會加入 &lt;code&gt;checksum&lt;/code&gt; 來驗證上面段落的有效性，&lt;code&gt;reader&lt;/code&gt; 可以藉由 &lt;code&gt;checksum&lt;/code&gt; 來辨識 &lt;code&gt;padding&lt;/code&gt; 或者 &lt;code&gt;duplicates&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 paper 中也有簡單說明如果 &lt;code&gt;application&lt;/code&gt; 某些應用場景無法忍受偶發的重複資料，可以在 &lt;code&gt;checkpoint&lt;/code&gt; 的地方加入一個 &lt;code&gt;unique identifiers&lt;/code&gt;，讀入資料的時候可以藉由 ID 來避免重複資料。&lt;/p&gt;
&lt;h2 id=&#34;system-interactions&#34;&gt;&lt;a href=&#34;#system-interactions&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;System interactions
&lt;/h2&gt;&lt;h3 id=&#34;lease租約&#34;&gt;&lt;a href=&#34;#lease%e7%a7%9f%e7%b4%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Lease(租約)
&lt;/h3&gt;&lt;p&gt;因為我們每份 &lt;code&gt;chunk&lt;/code&gt; 都會備份在不同的 &lt;code&gt;chunk server&lt;/code&gt; 內，所以需要有一個機制在修改完 &lt;code&gt;chunk&lt;/code&gt; 之後讓所有複製的 &lt;code&gt;chunk&lt;/code&gt; 都相同的內容。&lt;code&gt;GFS&lt;/code&gt; 中使用 &lt;code&gt;leases&lt;/code&gt; 去處理多個 &lt;code&gt;chunk&lt;/code&gt; 在經過修改之後的一致性問題。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;&lt;a href=&#34;#reference&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;reference
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.itread01.com/content/1546962067.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google File System及其繼任者Colossus
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/papers/gfs.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The Google File System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/schedule.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MIT6.824&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.open-open.com/lib/view/open1328763454608.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GFS 中文參考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
